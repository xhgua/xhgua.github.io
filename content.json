{"posts":[{"title":"dfs 序求 LCA","text":"$\\mathcal{O}(n\\log n) - \\mathcal{O}(1)$ 求 LCA 的科技！ 考虑对一棵树进行 dfs 的过程，对于两个点 $u, v$（不妨设 $\\operatorname{dfn}_u \\lt \\operatorname{dfn}_v$），dfs 时，我们总是先从 $\\operatorname{lca}(u, v)$ 下到 $u$ 点，再回到 $\\operatorname{lca}(u, v)$，然后再下到 $v$ 点。 我们发现，总有一个 $\\operatorname{lca(u, v)}$ 的儿子，它的 $\\operatorname{dfn}$ 是落在 $[\\operatorname{dfn}_u, \\operatorname{dfn}_v]$ 之间的（考虑从 $\\operatorname{lca}(u, v)$ 下到 $v$ 点的过程，总会经过它到 $v$ 这条链上的儿子）。 而 $\\operatorname{dfn}$ 在 $[\\operatorname{dfn}_u, \\operatorname{dfn}_v]$ 之间的所有点的深度都不会小于或等于 $\\operatorname{lca}(u, v)$。 于是我们只需要找到 $\\operatorname{dfn}$ 在 $[\\operatorname{dfn}_u, \\operatorname{dfn}_v]$ 之间的深度最小的点即可，$\\operatorname{lca}(u, v)$ 即为该点的父亲。 发现 $u$ 是 $v$ 的祖先时会出问题，我们令查询区间从 $[\\operatorname{dfn}_u, \\operatorname{dfn}_v]$ 变为 $[\\operatorname{dfn}_u + 1, \\operatorname{dfn}_v]$ 即可，不会影响先前的结论。 使用 ST 表可以做到 $\\mathcal{O}(n\\log n) - \\mathcal{O}(1)$。 $\\large\\textbf{Code:}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define i64 long long#define all(x) x.begin(), x.end()#define seg(a, l, r) a + l, a + r + 1#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)using namespace std;const int N = 5e5 + 5, M = 5e5 + 5, LOG = 20;struct Edge { int u, v, nxt; Edge() {} Edge(int _u, int _v, int _nxt) { u = _u; v = _v; nxt = _nxt; }} E[M &lt;&lt; 1];int n, m, root, tot, timer;int head[N], dfn[N], dep[N], fa[N], lg2[N];int stLCA[LOG][N];void addEdge(int u, int v) { E[tot] = Edge(u, v, head[u]); head[u] = tot++;}void dfs(int u, int f) { dfn[u] = ++timer; dep[u] = dep[f] + 1; fa[u] = f; stLCA[0][dfn[u]] = u; for(int i = head[u]; ~i; i = E[i].nxt) { int v = E[i].v; if(v == f) continue; dfs(v, u); }}int get(int u, int v) { return dep[u] &lt; dep[v] ? u : v;}int LCA(int u, int v) { if(u == v) return u; if(dfn[u] &gt; dfn[v]) swap(u, v); u = dfn[u] + 1, v = dfn[v]; int k = lg2[v - u + 1]; return fa[get(stLCA[k][u], stLCA[k][v - (1 &lt;&lt; k) + 1])];}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(head, -1, sizeof(head)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; root; lg2[1] = 0; rep(i, 2, n) lg2[i] = lg2[i &gt;&gt; 1] + 1; rep(i, 1, n - 1) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, v); addEdge(v, u); } dfs(root, 0); rep(j, 1, lg2[n]) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) stLCA[j][i] = get(stLCA[j - 1][i], stLCA[j - 1][i + (1 &lt;&lt; j - 1)]); while(m--) { int u, v; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; LCA(u, v) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/10/15/dfs-%E5%BA%8F%E6%B1%82-LCA/"}],"tags":[{"name":"OI Note","slug":"OI-Note","link":"/tags/OI-Note/"}],"categories":[],"pages":[]}