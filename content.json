{"posts":[{"title":"dfs 序求 LCA","text":"$\\mathcal{O}(n\\log n) - \\mathcal{O}(1)$ 求 LCA 的科技！ 考虑对一棵树进行 dfs 的过程，对于两个点 $u, v$（不妨设 $\\operatorname{dfn}_u \\lt \\operatorname{dfn}_v$），dfs 时，我们总是先从 $\\operatorname{lca}(u, v)$ 下到 $u$ 点，再回到 $\\operatorname{lca}(u, v)$，然后再下到 $v$ 点。 我们发现，总有一个 $\\operatorname{lca(u, v)}$ 的儿子，它的 $\\operatorname{dfn}$ 是落在 $[\\operatorname{dfn}_u, \\operatorname{dfn}_v]$ 之间的（考虑从 $\\operatorname{lca}(u, v)$ 下到 $v$ 点的过程，总会经过它到 $v$ 这条链上的儿子）。 而 $\\operatorname{dfn}$ 在 $[\\operatorname{dfn}_u, \\operatorname{dfn}_v]$ 之间的所有点的深度都不会小于或等于 $\\operatorname{lca}(u, v)$。 于是我们只需要找到 $\\operatorname{dfn}$ 在 $[\\operatorname{dfn}_u, \\operatorname{dfn}_v]$ 之间的深度最小的点即可，$\\operatorname{lca}(u, v)$ 即为该点的父亲。 发现 $u$ 是 $v$ 的祖先时会出问题，我们令查询区间从 $[\\operatorname{dfn}_u, \\operatorname{dfn}_v]$ 变为 $[\\operatorname{dfn}_u + 1, \\operatorname{dfn}_v]$ 即可，不会影响先前的结论。 使用 ST 表可以做到 $\\mathcal{O}(n\\log n) - \\mathcal{O}(1)$。 $\\large\\textbf{Code:}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define i64 long long#define all(x) x.begin(), x.end()#define seg(a, l, r) a + l, a + r + 1#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)using namespace std;const int N = 5e5 + 5, M = 5e5 + 5, LOG = 20;struct Edge { int u, v, nxt; Edge() {} Edge(int _u, int _v, int _nxt) { u = _u; v = _v; nxt = _nxt; }} E[M &lt;&lt; 1];int n, m, root, tot, timer;int head[N], dfn[N], dep[N], fa[N], lg2[N];int stLCA[LOG][N];void addEdge(int u, int v) { E[tot] = Edge(u, v, head[u]); head[u] = tot++;}void dfs(int u, int f) { dfn[u] = ++timer; dep[u] = dep[f] + 1; fa[u] = f; stLCA[0][dfn[u]] = u; for(int i = head[u]; ~i; i = E[i].nxt) { int v = E[i].v; if(v == f) continue; dfs(v, u); }}int get(int u, int v) { return dep[u] &lt; dep[v] ? u : v;}int LCA(int u, int v) { if(u == v) return u; if(dfn[u] &gt; dfn[v]) swap(u, v); u = dfn[u] + 1, v = dfn[v]; int k = lg2[v - u + 1]; return fa[get(stLCA[k][u], stLCA[k][v - (1 &lt;&lt; k) + 1])];}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(head, -1, sizeof(head)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; root; lg2[1] = 0; rep(i, 2, n) lg2[i] = lg2[i &gt;&gt; 1] + 1; rep(i, 1, n - 1) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, v); addEdge(v, u); } dfs(root, 0); rep(j, 1, lg2[n]) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) stLCA[j][i] = get(stLCA[j - 1][i], stLCA[j - 1][i + (1 &lt;&lt; j - 1)]); while(m--) { int u, v; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; LCA(u, v) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/10/15/dfs-%E5%BA%8F%E6%B1%82-LCA/"},{"title":"快速傅里叶变换 (FFT) 学习笔记","text":"多项式对于一个 $n + 1$ 次多项式 $A(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_{n} x ^ {n}$，有以下两种表示方法： 系数表示：由上文提到的 $(a_0, a_1, a_2, \\cdots, a_{n})$ 这 $n + 1$ 个系数来表示一个 $n$ 次多项式。 点值表示：由 $(x_0, y_0), (x_1, y_1), \\cdots, (x_{n}, y_{n})$ 这 $n + 1$ 个点来表示一个 $n$ 次多项式，其中对于 $\\forall i \\in [0, n]$，有 $y_i = A(x_i)$。所以一个多项式也可以被写作 $\\{(x_0, A(x_0)), (x_1, A(x_1)), \\cdots, (x_{n}, A(x_{n}))\\}$。 多项式卷积 / 乘法对于两个多项式 $A(x), B(x)$，定义卷积运算 $A(x) * B(x) = C(x)$，其中 $C(x)$ 满足 $c_k = \\sum\\limits_{i \\oplus j = k} a_ib_j$。 这里的 $\\oplus$ 符号表示某种二元运算符，当 $\\oplus$ 为加法操作时即为常见的多项式乘法。 所以显然我们可以使用如下代码计算两个多项式乘法的结果： 12345678vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) { int n = A.size(), m = B.size(); vector&lt;int&gt; C(n + m - 1, 0); rep(i, 0, n - 1) rep(j, 0, m - 1) C[i + j] += A[i] * B[j]; return C;} 时间复杂度为 $\\mathcal{O}(n ^ 2)$。 点值表示法的优势系数表示法固然很方便，但是在进行多项式乘法时，点值表示法的优势就体现出来了。 考虑由 $A(x)$ 和 $B(x)$ 的点值表示法计算出 $C(x)$ 的点值表示法。 则 $C(x)$ 即为 $\\{(x_0, A(x_0) \\times B(x_0)), (x_1, A(x_1) \\times B(x_1)), \\cdots, (x_{n + m}, A(x_{n + m}) \\times B(x_{n + m}))\\}$。 也就是说多项式乘法在点值表示法下可以 $\\mathcal{O}(n)$ 计算，这启发我们设计如下算法来计算多项式乘法： 将 $A(x)$ 和 $B(x)$ 转为点值表示法。 在点值表示法下计算 $A(x)$ 和 $B(x)$ 的乘积 $C(x)$。 将 $C(x)$ 转回系数表示法。 所以我们如果能够在较低的时间复杂度内将系数表示法转化为点值表示法，再将点值表示法转回系数表示法，就能以较低的时间复杂度计算多项式的乘法。 离散傅里叶变换 (DFT)即令 $x_0 = \\omega_n ^ 0, x_1 = \\omega_n ^ 1, \\cdots, x_{n - 1} = \\omega_n ^ {n - 1}$ 代入多项式中得到的点值。 写成矩阵的形式就是： \\begin{bmatrix} 1 & 1 & 1 & \\cdots & 1 \\\\ 1 & (\\omega_n ^ 1) ^ 1 & (\\omega_n ^ 1) ^ 2 & \\cdots & (\\omega_n ^ 1) ^ {n - 1} \\\\ 1 & (\\omega_n ^ 2) ^ 1 & (\\omega_n ^ 2) ^ 2 & \\cdots & (\\omega_n ^ 2) ^ {n - 1} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & (\\omega_n ^ {n - 1}) ^ 1 & (\\omega_n ^ {n - 1}) ^ 2 & \\cdots & (\\omega_n ^ {n - 1}) ^ {n - 1} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n - 1} \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_{n - 1} \\end{bmatrix}其中 $\\omega_n$ 表示 $n$ 次单位根，即 $\\omega_n = \\cos \\frac{2\\pi}{n} + i\\sin \\frac{2\\pi}{n}$。 由欧拉公式可以得到 $\\omega_n ^ k = \\cos \\frac{2k\\pi}{n} + i\\sin \\frac{2k\\pi}{n}$。 离散傅里叶逆变换 (IDFT)为什么 DFT 中要代入单位根呢？自然有他的用处。 考虑将点值表示法转回系数表示法。 观察上述式子，我们只需在等式两边同时左乘一个单位根矩阵的逆即可。 通过范德蒙德矩阵求逆，我们得到： \\begin{bmatrix} 1 & 1 & 1 & \\cdots & 1 \\\\ 1 & (\\omega_n ^ 1) ^ 1 & (\\omega_n ^ 1) ^ 2 & \\cdots & (\\omega_n ^ 1) ^ {n - 1} \\\\ 1 & (\\omega_n ^ 2) ^ 1 & (\\omega_n ^ 2) ^ 2 & \\cdots & (\\omega_n ^ 2) ^ {n - 1} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & (\\omega_n ^ {n - 1}) ^ 1 & (\\omega_n ^ {n - 1}) ^ 2 & \\cdots & (\\omega_n ^ {n - 1}) ^ {n - 1} \\end{bmatrix}^{-1} = \\dfrac{1}{n}\\begin{bmatrix} 1 & 1 & 1 & \\cdots & 1 \\\\ 1 & (\\omega_n ^ {n - 1}) ^ 1 & (\\omega_n ^ {n - 1}) ^ 2 & \\cdots & (\\omega_n ^ {n - 1}) ^ {n - 1} \\\\ 1 & (\\omega_n ^ {n - 2}) ^ 1 & (\\omega_n ^ {n - 2}) ^ 2 & \\cdots & (\\omega_n ^ {n - 2}) ^ {n - 1} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & (\\omega_n ^ {1}) ^ 1 & (\\omega_n ^ {1}) ^ 2 & \\cdots & (\\omega_n ^ {1}) ^ {n - 1} \\end{bmatrix}所以有： \\dfrac{1}{n}\\begin{bmatrix} 1 & 1 & 1 & \\cdots & 1 \\\\ 1 & (\\omega_n ^ {n - 1}) ^ 1 & (\\omega_n ^ {n - 1}) ^ 2 & \\cdots & (\\omega_n ^ {n - 1}) ^ {n - 1} \\\\ 1 & (\\omega_n ^ {n - 2}) ^ 1 & (\\omega_n ^ {n - 2}) ^ 2 & \\cdots & (\\omega_n ^ {n - 2}) ^ {n - 1} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & (\\omega_n ^ {1}) ^ 1 & (\\omega_n ^ {1}) ^ 2 & \\cdots & (\\omega_n ^ {1}) ^ {n - 1} \\end{bmatrix} \\begin{bmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_{n - 1} \\end{bmatrix} = \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n - 1} \\end{bmatrix}所以本质上 DFT 和 IDFT 可以用同样的方法来完成，只是代入的 $x$ 值不同而已。 快速傅里叶变换 (FFT)然而 DFT 的复杂度还是 $\\mathcal{O}(n ^ 2)$，能不能更快？ 考虑使用分治。 假设我们要将多项式 $A(x) = a_0 + a_1x + a_2x ^ 2 + \\cdots + a_{n - 1}x ^ {n - 1}$ 转为点值表示法，我们按照下标奇偶性将 $A(x)$ 中的项分为两部分，即： \\begin{aligned} A(x) &= a_0 + a_2x ^ 2 + a_4x ^ 4 + \\cdots + a_{n - 2}x^{n - 2} \\\\ &+ a_1x + a_3x ^ 3 + a_5x ^ 5 + \\cdots + a_{n - 1}x^{n - 1} \\\\ \\end{aligned}为了方便，我们假设 $n$ 为 $2$ 的幂次，这样子除以 $2$ 时不会出现除不尽的情况。 我们设： \\begin{aligned} A_{\\text{even}}(x) = a_0 + a_2x + a_4x ^ 2 + \\cdots + a_{n - 2}x^{n / 2 - 1} \\\\ A_{\\text{odd}}(x) = a_1 + a_3x + a_5x ^ 2 + \\cdots + a_{n - 1}x^{n / 2 - 1} \\end{aligned}所以有： A(x) = A_{\\text{even}}(x ^ 2) + xA_{\\text{odd}}(x ^ 2)划分好之后，我们尝试代入 $x = \\omega_n^k\\ (k \\lt \\dfrac{n}{2})$： \\begin{aligned} A(x) &= A_{\\text{even}}(\\omega_n^{2k}) + \\omega_n^kA_{\\text{odd}}(\\omega_n^{2k}) \\\\ &= A_{\\text{even}}(\\omega_{\\frac{n}{2}}^{k}) + \\omega_n^kA_{\\text{odd}}(\\omega_{\\frac{n}{2}}^{k})\\\\ \\end{aligned}继续代入 $x = \\omega_n^{k + \\frac{n}{2}}\\ (k \\lt \\dfrac{n}{2})$： \\begin{aligned} A(x) &= A_{\\text{even}}(\\omega_n^{2k + n}) + \\omega_n^{k + \\frac{n}{2}}A_{\\text{odd}}(\\omega_n^{2k + n}) \\\\ &= A_{\\text{even}}(\\omega_n^{2k}) - \\omega_n^kA_{\\text{odd}}(\\omega_n^{2k}) \\\\ &= A_{\\text{even}}(\\omega_{\\frac{n}{2}}^{k}) - \\omega_n^kA_{\\text{odd}}(\\omega_{\\frac{n}{2}}^{k})\\\\ \\end{aligned}由于单位根的奇妙性质，两式仅有一个正负号不同，于是对于每个 $k \\in [1, \\dfrac{n}{2} - 1]$，我们只需求 $A_{\\text{even}}(\\omega_{\\frac{n}{2}}^{k})$ 和 $A_{\\text{odd}}(\\omega_{\\frac{n}{2}}^{k})$ 的值即可算出 $A(\\omega_n^k)$ 和 $A(\\omega_n^{k + \\frac{n}{2}})$。 而 $A_{\\text{even}}$ 和 $A_{\\text{odd}}$ 是两个规模减半的子问题，可以递归计算。 时间复杂度 $T(n) = 2T(\\frac{n}{2}) + \\mathcal{O}(n) = \\mathcal{O}(n \\log n)$。 逆变换也是类似，注意到 $\\omega_n^{k}$ 与 $\\omega_n^{n - k}$ 互为共轭，所以只需要在单位根的虚部处加一个负号即可。 在实现时，可以将 FFT 和 IFFT 放在同个函数内实现，当 inv = 1 时为 FFT，inv = -1 时为 IFFT，减小码量。 Complex 类自己手写会快一点。 1234567891011121314151617181920212223242526272829303132struct Complex { double a, b; // a + b * i Complex() {} Complex(double _a, double _b) { a = _a; b = _b; } Complex operator + (Complex const &amp;rhs) const { return Complex(a + rhs.a, b + rhs.b); } Complex operator - (Complex const &amp;rhs) const { return Complex(a - rhs.a, b - rhs.b); } Complex operator * (Complex const &amp;rhs) const { return Complex(a * rhs.a - b * rhs.b, a * rhs.b + b * rhs.a); }};void FFT(vector&lt;Complex&gt; &amp;A, int n, int inv) { if(n == 1) return; vector&lt;Complex&gt; e(n / 2), o(n / 2); for(int i = 0; i &lt; n; i += 2) { e[i / 2] = A[i]; o[i / 2] = A[i + 1]; } FFT(e, n / 2, inv); FFT(o, n / 2, inv); Complex wn(cos(2 * PI / n), inv * sin(2 * PI / n)), wk(1, 0); for(int i = 0; i &lt; n / 2; i++, wk = wk * wn) { A[i] = e[i] + wk * o[i]; A[i + len / 2] = e[i] - wk * o[i]; }} 三次变两次优化假设我们要求 $A(x) * B(x)$，我们设复多项式 $P(x) = A(x) + B(x)i$，也就是 $P$ 的实部为 $A$，虚部为 $B$。 则有 $P(x)^2 = A(x)^2 - B(x)^2 + 2A(x)*B(x)i$，所以我们把 $B(x)$ 的系数放到虚部上，然后求出 $P(x)^2$，将其虚部除以 $2$ 即可。 这样一来我们只需用对 $P$ 做一次 FFT 和一次 IFFT，常数是原来的 $\\dfrac{2}{3}$。 完整代码（省略 FastIO）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define i64 long long #define all(x) x.begin(), x.end()#define seg(a, l, r) a + l, a + r + 1#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)using namespace std;using namespace FastIO;const int N = 1e6 + 5;const double PI = acos(-1.0), EPS = 1e-8;struct Complex { double a, b; // a + b * i Complex() {} Complex(double _a, double _b) { a = _a; b = _b; } Complex operator + (Complex const &amp;rhs) const { return Complex(a + rhs.a, b + rhs.b); } Complex operator - (Complex const &amp;rhs) const { return Complex(a - rhs.a, b - rhs.b); } Complex operator * (Complex const &amp;rhs) const { return Complex(a * rhs.a - b * rhs.b, a * rhs.b + b * rhs.a); }};int n, m;vector&lt;Complex&gt; a;void FFT(vector&lt;Complex&gt; &amp;arr, int len, int inv) { if(len == 1) return; vector&lt;Complex&gt; e(len / 2), o(len / 2); for(int i = 0; i &lt; len; i += 2) { e[i / 2] = arr[i]; o[i / 2] = arr[i + 1]; } FFT(e, len / 2, inv); FFT(o, len / 2, inv); Complex wn(cos(2 * PI / len), inv * sin(2 * PI / len)), wk(1, 0); for(int i = 0; i &lt; len / 2; i++, wk = wk * wn) { Complex val = wk * o[i]; arr[i] = e[i] + val; arr[i + len / 2] = e[i] - val; }}int main() { read(n); read(m); int len = 1; while(len &lt; n + m + 1) len *= 2; a.resize(len); rep(i, 0, n) { int x; read(x); a[i].a = x; } rep(i, 0, m) { int x; read(x); a[i].b = x; } FFT(a, len, 1); rep(i, 0, len - 1) a[i] = a[i] * a[i]; FFT(a, len, -1); rep(i, 0, n + m) writesp((int)round(a[i].b / 2 / len + EPS)); return flush(), 0;}","link":"/2023/10/15/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"OI Note","slug":"OI-Note","link":"/tags/OI-Note/"}],"categories":[],"pages":[]}