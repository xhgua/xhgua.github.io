{"posts":[{"title":"2023 正睿 NOIP 十连测","text":"NOIP 十连测 Day1 T4 康乃馨 给定一个 nnn 个节点的仙人掌，每条边上有两个权值 ai,bia_i, b_iai​,bi​。 一个生成树的权值是 ∑ai×∑bi\\sum a_i \\times \\sum b_i∑ai​×∑bi​，请求出这个仙人掌的最小生成树，输出最小权值。 仙人掌是每个边最多只在一个环里的联通无向图。 n≤2×105,m≤3×105,max⁡(ai,bi)≤104n \\leq 2\\times 10 ^ 5, m \\leq 3\\times 10^5, \\max(a_i, b_i) \\leq 10 ^ 4n≤2×105,m≤3×105,max(ai​,bi​)≤104。 Sol: 对于每棵生成树，将其抽象为点 (∑a,∑b)(\\sum a, \\sum b)(∑a,∑b) ，那我们就是要求一个最小的 ansansans，使得存在一点落在函数 f(x)=ansxf(x) = \\dfrac{ans}{x}f(x)=xans​ 上。 不难发现只有在凸包上的点可能成为答案。 而仙人掌的生成树等价于给每个环断开一条边，假设第一个环断边之后可能为 (a1,b1)(a_1, b_1)(a1​,b1​)，第二个环断边之后可能为 (a2,b2)(a_2, b_2)(a2​,b2​)，那么两个环加起来就是 (a1+a2,b1+b2)(a_1 + a_2, b_1 + b_2)(a1​+a2​,b1​+b2​)，而这正是闵可夫斯基和的形式。 所以我们可以对每个环先建立凸包，合并用闵可夫斯基和，有多个就分治合并即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;bits/stdc++.h&gt;#define i64 long long#define all(x) x.begin(), x.end()#define seg(a, l, r) a + l, a + r + 1#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)using namespace std;const int N = 2e5 + 5, M = 5e5 + 5;struct Edge { int u, v, nxt; i64 a, b; Edge() {} Edge(int _u, int _v, i64 _a, i64 _b, int _nxt) { u = _u; v = _v; nxt = _nxt; a = _a; b = _b; }} E[M &lt;&lt; 1];struct Point { i64 x, y; Point() {} Point(i64 _x, i64 _y) { x = _x; y = _y; } Point operator + (const Point &amp;rhs) const { return Point(x + rhs.x, y + rhs.y); } Point operator - (const Point &amp;rhs) const { return Point(x - rhs.x, y - rhs.y); } double len() { return hypot(x, y); }};i64 cross(Point lhs, Point rhs) { return lhs.x * rhs.y - lhs.y * rhs.x;}int n, m, tot, cycleTot, convexTot;int head[N], fa[N], faEdge[N];bool vis[M &lt;&lt; 1], isCycle[M &lt;&lt; 1];vector&lt;pair&lt;i64, i64&gt;&gt; cycle[N];vector&lt;Point&gt; convex[N];void addEdge(int u, int v, i64 a, i64 b) { E[tot] = Edge(u, v, a, b, head[u]); head[u] = tot++;}void dfs(int u, int f, int last) { fa[u] = f; faEdge[u] = (last ^ 1); for(int i = head[u]; ~i; i = E[i].nxt) { if(vis[i]) continue; int v = E[i].v; if(fa[v] != 0) { cycleTot++; int t = u; while(t != v) { cycle[cycleTot].push_back(make_pair(E[faEdge[t]].a, E[faEdge[t]].b)); isCycle[faEdge[t]] = isCycle[faEdge[t] ^ 1] = true; t = E[faEdge[t]].v; } cycle[cycleTot].push_back(make_pair(E[i].a, E[i].b)); isCycle[i] = isCycle[i ^ 1] = true; vis[i] = vis[i ^ 1] = true; } else vis[i] = vis[i ^ 1] = true, dfs(v, u, i); }}vector&lt;Point&gt; convexHull(vector&lt;Point&gt; P) { vector&lt;Point&gt; ret; sort(all(P), [&amp;](const Point &amp;lhs, const Point &amp;rhs) { return lhs.y == rhs.y ? lhs.x &lt; rhs.x : lhs.y &lt; rhs.y; }); sort(P.begin() + 1, P.end(), [&amp;](const Point &amp;lhs, const Point &amp;rhs) { Point L = lhs - P[0], R = rhs - P[0]; if(cross(L, R) == 0) return L.len() &lt; R.len(); return cross(L, R) &lt; 0; }); int siz = P.size(); rep(i, 0, siz - 1) { Point u = P[i]; while(ret.size() &gt; 1 &amp;&amp; cross(u - ret[ret.size() - 2], ret[ret.size() - 1] - ret[ret.size() - 2]) &lt;= 0) ret.pop_back(); ret.push_back(u); } return ret;}vector&lt;Point&gt; Minkowski(vector&lt;Point&gt; lhs, vector&lt;Point&gt; rhs) { int sizL = lhs.size(), sizR = rhs.size(); if(1ll * sizL * sizR &lt;= 10) { vector&lt;Point&gt; ret; for(auto p1 : lhs) for(auto p2 : rhs) ret.push_back(p1 + p2); return convexHull(ret); } vector&lt;Point&gt; ret, L(sizL), R(sizR); ret.push_back(lhs[0] + rhs[0]); rep(i, 0, sizL - 1) L[i] = lhs[(i + 1) % sizL] - lhs[i]; rep(i, 0, sizR - 1) R[i] = rhs[(i + 1) % sizR] - rhs[i]; int pl = 0, pr = 0; while(pl &lt; sizL &amp;&amp; pr &lt; sizR) ret.push_back(ret.back() + (cross(L[pl], R[pr]) &lt;= 0 ? L[pl++] : R[pr++])); while(pl &lt; sizL) ret.push_back(ret.back() + L[pl++]); while(pr &lt; sizR) ret.push_back(ret.back() + R[pr++]); return ret;}vector&lt;Point&gt; solve(int l, int r) { if(l == r) return convex[l]; int mid = (l + r) &gt;&gt; 1; return Minkowski(solve(l, mid), solve(mid + 1, r));}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(head, -1, sizeof(head)); cin &gt;&gt; n &gt;&gt; m; rep(i, 1, m) { int u, v; i64 a, b; cin &gt;&gt; u &gt;&gt; v &gt;&gt; a &gt;&gt; b; addEdge(u, v, a, b); addEdge(v, u, a, b); } dfs(1, -1, -1); i64 sumA = 0, sumB = 0; rep(i, 0, m - 1) if(!isCycle[i * 2]) sumA += E[i * 2].a, sumB += E[i * 2].b; rep(i, 1, cycleTot) { i64 totA = 0, totB = 0; for(auto p : cycle[i]) totA += p.first, totB += p.second; for(auto p : cycle[i]) convex[i].push_back(Point(totA - p.first, totB - p.second)); convex[i] = convexHull(convex[i]); } if(cycleTot == 0) { cout &lt;&lt; sumA * sumB &lt;&lt; &quot;\\n&quot;; return 0; } vector&lt;Point&gt; con = solve(1, cycleTot); con = convexHull(con); i64 ans = LLONG_MAX; for(auto p : con) ans = min(ans, (sumA + p.x) * (sumB + p.y)); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2023/10/20/2023-%E6%AD%A3%E7%9D%BF-NOIP-%E5%8D%81%E8%BF%9E%E6%B5%8B/"},{"title":"dfs 序求 LCA","text":"O(nlog⁡n)−O(1)\\mathcal{O}(n\\log n) - \\mathcal{O}(1)O(nlogn)−O(1) 求 LCA 的科技！ 考虑对一棵树进行 dfs 的过程，对于两个点 u,vu, vu,v（不妨设 dfn⁡u&lt;dfn⁡v\\operatorname{dfn}_u \\lt \\operatorname{dfn}_vdfnu​&lt;dfnv​），dfs 时，我们总是先从 lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v) 下到 uuu 点，再回到 lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v)，然后再下到 vvv 点。 我们发现，总有一个 lca(u,v)⁡\\operatorname{lca(u, v)}lca(u,v) 的儿子，它的 dfn⁡\\operatorname{dfn}dfn 是落在 [dfn⁡u,dfn⁡v][\\operatorname{dfn}_u, \\operatorname{dfn}_v][dfnu​,dfnv​] 之间的（考虑从 lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v) 下到 vvv 点的过程，总会经过它到 vvv 这条链上的儿子）。 而 dfn⁡\\operatorname{dfn}dfn 在 [dfn⁡u,dfn⁡v][\\operatorname{dfn}_u, \\operatorname{dfn}_v][dfnu​,dfnv​] 之间的所有点的深度都不会小于或等于 lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v)。 于是我们只需要找到 dfn⁡\\operatorname{dfn}dfn 在 [dfn⁡u,dfn⁡v][\\operatorname{dfn}_u, \\operatorname{dfn}_v][dfnu​,dfnv​] 之间的深度最小的点即可，lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v) 即为该点的父亲。 发现 uuu 是 vvv 的祖先时会出问题，我们令查询区间从 [dfn⁡u,dfn⁡v][\\operatorname{dfn}_u, \\operatorname{dfn}_v][dfnu​,dfnv​] 变为 [dfn⁡u+1,dfn⁡v][\\operatorname{dfn}_u + 1, \\operatorname{dfn}_v][dfnu​+1,dfnv​] 即可，不会影响先前的结论。 使用 ST 表可以做到 O(nlog⁡n)−O(1)\\mathcal{O}(n\\log n) - \\mathcal{O}(1)O(nlogn)−O(1)。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define i64 long long#define all(x) x.begin(), x.end()#define seg(a, l, r) a + l, a + r + 1#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)using namespace std;const int N = 5e5 + 5, M = 5e5 + 5, LOG = 20;struct Edge { int u, v, nxt; Edge() {} Edge(int _u, int _v, int _nxt) { u = _u; v = _v; nxt = _nxt; }} E[M &lt;&lt; 1];int n, m, root, tot, timer;int head[N], dfn[N], dep[N], fa[N], lg2[N];int stLCA[LOG][N];void addEdge(int u, int v) { E[tot] = Edge(u, v, head[u]); head[u] = tot++;}void dfs(int u, int f) { dfn[u] = ++timer; dep[u] = dep[f] + 1; fa[u] = f; stLCA[0][dfn[u]] = u; for(int i = head[u]; ~i; i = E[i].nxt) { int v = E[i].v; if(v == f) continue; dfs(v, u); }}int get(int u, int v) { return dep[u] &lt; dep[v] ? u : v;}int LCA(int u, int v) { if(u == v) return u; if(dfn[u] &gt; dfn[v]) swap(u, v); u = dfn[u] + 1, v = dfn[v]; int k = lg2[v - u + 1]; return fa[get(stLCA[k][u], stLCA[k][v - (1 &lt;&lt; k) + 1])];}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(head, -1, sizeof(head)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; root; lg2[1] = 0; rep(i, 2, n) lg2[i] = lg2[i &gt;&gt; 1] + 1; rep(i, 1, n - 1) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, v); addEdge(v, u); } dfs(root, 0); rep(j, 1, lg2[n]) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) stLCA[j][i] = get(stLCA[j - 1][i], stLCA[j - 1][i + (1 &lt;&lt; j - 1)]); while(m--) { int u, v; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; LCA(u, v) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/10/15/dfs-%E5%BA%8F%E6%B1%82-LCA/"},{"title":"CSP-S 2023 游记","text":"高中 OI 生涯第一战。 9.16 初赛 小图灵估分 81.5，比去年稍微低一点，不过过初赛应该是没问题了。 2B 铅笔坏了导致耽误了一些时间，最后没有充足的时间去检查，还把一道原本选对的题改错了/kk，以及一道题看反了，还有零零碎碎的小错误，导致了这个分数。 不过再怎么说也应该是过初赛了，希望复赛能够 rp++ qwq。 9.23 Day -28 周六是每周唯二的竞赛训练之一。 机房换了新机，但是 Windows 版本太低了（甚至禁用了更新），感觉不是很舒服。 不过 Sublime 等东西还是配置好了，有了一个还算不错的写题环境。 以后做题当作模拟赛打，每档部分分都尽量想一想。 学习了后缀数组/kel，没用的技能树又多了。 9.25 Day -26 温岭中学机房全员过初赛！ 周一下午最后一节课社团，无人机社社长是郑神，所以直接机房启动。 补一补游记。 9.27 Day -24 wyz 的 BDOI Round1。 作为验题人，验了一道数据结构和一道状压。 在其他人打比赛的时候造了一题的数据，好难造。 造了一下午 + 一晚上，终于把一些错误代码卡掉了。 whk 好摆，感觉最近好颓的说。 9.30 Day -21 一天中秋，一天国庆，构成了一个温中人的全部假期。 给自己建了个远程仓库，放一些 OI 代码，这样就不用移动硬盘拷来拷去了。 回老家颓废。 明天国庆第一天，也是最后一天，继续颓。 10.2 Day -19 回校咯。 上午校内模拟赛，30 min 签了 T1 和 T2，T3 范围 n≤50n \\leq 50n≤50，直接写了个 O(n6)\\mathcal{O}(n ^ 6)O(n6) 的二维区间 dp（实际上跑不满），本地测极限数据跑了 950ms，相信海波的评测机！ T4 10 分暴力滚粗了。 估分 100+100+100+10=310100 + 100 + 100 + 10 = 310100+100+100+10=310。 赛后去 OJ 上测了一发 T3，T 掉了？？？ 但是好在用的是海波本机评测，最后还是冲过去了，没有挂分。 下午洛谷基础赛。 33s 过 A，3min 过 B，11min 过 C，喜提 B 一血 &amp; 前三题最快。 然后卡 T4 卡了 2h，最后还是 AK 了，喜提 rk6。 晚上补作业。 10.4 Day -17 上午 whk。 下午模拟赛。 T1 区间逆序对，第一眼 lxl，看见值域后是 easy 题。 T2 不是很会，写了个 O(n2)\\mathcal{O}(n ^ 2)O(n2) dp 拿了 60。 T3 写了假做法，过了 333 个大样例，被最后一个 hack 了。 T4 不会，20pts 滚粗。 估分 100+60+[10,100]+20=[190,280]100 + 60 + [10, 100] + 20 = [190, 280]100+60+[10,100]+20=[190,280]。 实际得分 100+60+100+20=280100 + 60 + 100 + 20 = 280100+60+100+20=280。 笑死了 T3 数据水的一批，放过一车假做法。 10.5 Day -16 上午 whk。 下午 whk。 晚上来机房胡题，秒了一道 *2200 和一道 *2400，感觉胡题能力有所提升！ 10.6 ~ 10.17 前面忘了。中间忘了。后面忘了。 10.18 Day -3 赛前最后一次模拟赛。 T1 签到，T2 写了 trie 树 + 拓扑排序判环，在大概 40min 的时候就丢掉了，也没上拍。 T3 是离散化之后 dp，硬冲了 2h 冲出来了一个 O(n6)\\mathcal{O}(n ^ 6)O(n6) 的 dp，又写了两个二维前缀和把它优化到了 O(n3)\\mathcal{O}(n ^ 3)O(n3)，但其实还多了个 log，赛时眼瞎没有看见，大样例跑了 6s，一直以为是常数太大了就丢了。 15min 写完 T4 暴力之后发现没有思路就跑回来给 T3 卡常，卡了半天卡进了 5s，但是没有一点卵用，最后还是被 ocean 一眼丁真出来才发现，预处理了逆元之后把 log 拿掉了。 估分 100+100+100+30=330100 + 100 + 100 + 30 = 330100+100+100+30=330。 实际得分 100+100+100+30=330100 + 100 + 100 + 30 = 330100+100+100+30=330。 10.20 Day -1 出发！ 吃完午饭后收拾一下行李就出发了，大概 5 点到了酒店，放了东西之后就去吃饭了。 海波还是兑现了他的初赛承诺，请我们吃了饭，然后一群人就在聊天吹水玩原神（雾）。 吃完饭回房间后直接启动了，跑到千然哥哥房间里启动宝可梦，但是因为玩不太来就放弃了，开始下铲。 中途鸡哥和 zr 过来了，于是在旁边观看保留节目 zr 和 czy 叫爹（我也输了两把呜呜呜）。 过了不知道多久铲终于下好了，和大便以及绫华狗一起开黑，好玩。 然后就是各种启动，这之间 szc 和 zhy 还过来了，把我给机惨了/kk，当时光顾着玩铲根本不清楚发生了什么，结果回去的时候打开洛谷一看… 看 B 站看到凌晨才睡，反正明早不考 J 组。 10.21 Day 0 早上 8 点自然醒了，继续颓 B 站，9 点左右和 czy 一起去吃早饭，碰到了海波以及路中（也许？）和北师大的教练在一起吃饭。 然后发现有个省考点没关网，题目传出来了，谔谔。 简单看了一下，前 3 道变水了，T4 变难了，相信他们大部分人应该都能一等！ 接着就出发去接人了，然后吃饭，休息，就准备进考场了。 还是有些慌的，毕竟去年 CE 了，今年不拿个一等回来说不过去（ 2:10 分的时候进了机房，又出去上了个厕所冷静了一下。 2:15 的时候发了解压密码，遂看题目名称以及大样例。 game 看上去是字符串计数，打算放第一个做；lock 怎么只有两个样例，甚至每行输入只有五个数，很奇怪；struct 一眼有关结构体的大模拟，直接 skip；tree 看题目名称就知道是树论，感觉是 T3 / T4。 2:25 发试题密码，浏览了一遍发现 lock 才是签到，而 game 有些没有思路，struct 和 tree 猜的八九不离十。 2:30 可以开始写代码了，首先花了 20 分钟把 lock 给写了，然后去想 game，但是机房里有点闷热，导致脑子晕晕的思考不动，在纸上写写画画了 30 分钟还是没有什么思路，就写了个 35 分的区间 dp 跑路了，甚至连栈模拟都没有想到，真的降智了。 这时候做了一个比较激进的决定：去冲大模拟 struct。 之前一直在教导别人不要先写大模拟，先要把其他题暴力打完了再留时间去冲，但是考场上的自己脑子一热就上头了，快速读完题面就开写了。写写删删了 1h 终于搞出来了一个能过样例 1 的代码，但是没有过样例 2。当时还是有一点点慌的，不过仔细又翻了遍题面，发现了数据范围下面有提示部分，这才发现关于结构体所占地址的定义搞错了，在反复手摸第二个样例之后得到了一个比较正确的定义以及写法，于是果断删掉代码重构，此时距比赛开始是 2.5h 左右。 可能是因为 zhy 机惨我带来的 rp，30min 左右就写好了新的一版，并顺利过了前两个样例，但是又被样例 3 卡掉了，检查发现是一个细节漏掉了，修改了一下就顺利跑过了三个样例。 这时候已经有 235 分了，我一再对自己说要稳扎稳打，把 T4 暴力拿下就能顺利一等。怀着忐忑的心情，我开始仔细读 tree 的题面。因为是 CSP-S 的 T4，我对它还是有一定的惧怕的，一开始认为它很不可做，所以准备把特殊性质逐一攻破。首先我注意到 B 性质的 ui=i,vi=i+1u_i = i, v_i = i + 1ui​=i,vi​=i+1，摆明了它是一条链，而链的情况种法是唯一的，所以只需要计算一下取个 max⁡\\maxmax 就可以了。 然而我首先想到的不是直接算，而是二分之后判断是否可行，这也给我之后的做法打下了基础。很快地写完这个性质之后，我便着手于性质 A 的 ci=0c_i = 0ci​=0，这意味这树木增长速度是恒定的，于是对于二分要判定的 mid，每棵树都有一个最晚种植时间 tit_iti​ 使得在第 tit_iti​ 天种它可以长到规定高度，而在第 ti+1t_i + 1ti​+1 天不行。于是我们将 ttt 求出来以后进行贪心即可。 这里我的贪心是每次选择 ttt 最小的那棵树，然后打通它到根的路径，显然这个做法是假的（upd：是我假了，做法是正确的，但是我写挂了），它也过不了 CCF 给的样例 2。 然后我沮丧地去看性质 D，发现可以直接把性质 A 的做法搬过来，求 tit_iti​ 的部分改为二分就行，因为在 D 性质的 ∀ui=1\\forall u_i = 1∀ui​=1 的限制下这个贪心是对的，所以立刻开始了 coding。然后我发现这个代码它跑过了所有大样例，当时有点兴奋，也有点上头了，把之前写的性质 AB 都删了，只放了一个 D 的代码上去。 这时候大概是 6:10，距离比赛结束还有 20min，我又思考了一会 T2，还是没有想出一些做法，只能一遍又一遍检查着文件输入输出以及命名。 6:30，结束了，希望能有一等 + 七级吧。 预估得分：100+35+100+[0,100]=[235,335]100 + 35 + 100 + [0, 100] = [235, 335]100+35+100+[0,100]=[235,335]。 核桃：100+35+100+100=335100 + 35 + 100 + 100 = 335100+35+100+100=335。 洛谷：100+35+100+50=285100 + 35 + 100 + 50 = 285100+35+100+50=285。 云斗：100+35+100+45=280100 + 35 + 100 + 45 = 280100+35+100+45=280。 计蒜客：100+35+100+40=275100 + 35 + 100 + 40 = 275100+35+100+40=275。 小图灵：100+35+100+15=250100 + 35 + 100 + 15 = 250100+35+100+15=250。 信友队：100+35+100+15=250100 + 35 + 100 + 15 = 250100+35+100+15=250。 看起来最后一题能有点分，一切都看 CCF 的数据了！ upd: 官方数据 100+35+100+80=315100 + 35 + 100 + 80 = 315100+35+100+80=315。 成功耗完 rp。 赛后总结 这次 S 组的题目出的没什么区分度，特别是 T1，放了个普及组难度的题，不是很懂 CCF 怎么想的。 T2 的做法十分简单，赛后发现有很多人都会，瞬间自闭，看来还是题目做的太少。 本场比赛唯一正确抉择就是去冲了 T3，貌似温中全员只有我一个冲了 T3 并且过了的，直接拉开分数。 有时候激进的策略还是挺有用的。 感觉 T2 这种题想不出来很小丑啊，NOIP 看来要加训思维了。 以后计划还是不往下学省选的知识了，先老老实实打好基础，大块的时间用来做模拟题，碎片时间用来补题，每周确保做 2 ~ 3 套模拟题并补掉，争取拿一个 NOIP 高分一等。","link":"/2023/10/22/CSP-S-2023-%E6%B8%B8%E8%AE%B0/"},{"title":"NOIP 2023 游记","text":"前情提要 CSP-S 2023 喜提 315 分，苟进了 NOIP。 Day -21 10.28","link":"/2023/10/28/NOIP-2023-%E6%B8%B8%E8%AE%B0/"},{"title":"快速傅里叶变换 (FFT) 学习笔记","text":"多项式 对于一个 n+1n + 1n+1 次多项式 A(x)=a0+a1x+a2x2+⋯+anxnA(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_{n} x ^ {n}A(x)=a0​+a1​x+a2​x2+⋯+an​xn，有以下两种表示方法： 系数表示： 由上文提到的 (a0,a1,a2,⋯ ,an)(a_0, a_1, a_2, \\cdots, a_{n})(a0​,a1​,a2​,⋯,an​) 这 n+1n + 1n+1 个系数来表示一个 nnn 次多项式。 点值表示： 由 (x0,y0),(x1,y1),⋯ ,(xn,yn)(x_0, y_0), (x_1, y_1), \\cdots, (x_{n}, y_{n})(x0​,y0​),(x1​,y1​),⋯,(xn​,yn​) 这 n+1n + 1n+1 个点来表示一个 nnn 次多项式，其中对于 ∀i∈[0,n]\\forall i \\in [0, n]∀i∈[0,n]，有 yi=A(xi)y_i = A(x_i)yi​=A(xi​)。 所以一个多项式也可以被写作 {(x0,A(x0)),(x1,A(x1)),⋯ ,(xn,A(xn))}\\{(x_0, A(x_0)), (x_1, A(x_1)), \\cdots, (x_{n}, A(x_{n}))\\}{(x0​,A(x0​)),(x1​,A(x1​)),⋯,(xn​,A(xn​))}。 多项式卷积 / 乘法 对于两个多项式 A(x),B(x)A(x), B(x)A(x),B(x)，定义卷积运算 A(x)∗B(x)=C(x)A(x) * B(x) = C(x)A(x)∗B(x)=C(x)，其中 C(x)C(x)C(x) 满足 ck=∑i⊕j=kaibjc_k = \\sum\\limits_{i \\oplus j = k} a_ib_jck​=i⊕j=k∑​ai​bj​。 这里的 ⊕\\oplus⊕ 符号表示某种二元运算符，当 ⊕\\oplus⊕ 为加法操作时即为常见的多项式乘法。 所以显然我们可以使用如下代码计算两个多项式乘法的结果： Code12345678vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) { int n = A.size(), m = B.size(); vector&lt;int&gt; C(n + m - 1, 0); rep(i, 0, n - 1) rep(j, 0, m - 1) C[i + j] += A[i] * B[j]; return C;} 时间复杂度为 O(n2)\\mathcal{O}(n ^ 2)O(n2)。 点值表示法的优势 系数表示法固然很方便，但是在进行多项式乘法时，点值表示法的优势就体现出来了。 考虑由 A(x)A(x)A(x) 和 B(x)B(x)B(x) 的点值表示法计算出 C(x)C(x)C(x) 的点值表示法。 则 C(x)C(x)C(x) 即为 {(x0,A(x0)×B(x0)),(x1,A(x1)×B(x1)),⋯ ,(xn+m,A(xn+m)×B(xn+m))}\\{(x_0, A(x_0) \\times B(x_0)), (x_1, A(x_1) \\times B(x_1)), \\cdots, (x_{n + m}, A(x_{n + m}) \\times B(x_{n + m}))\\}{(x0​,A(x0​)×B(x0​)),(x1​,A(x1​)×B(x1​)),⋯,(xn+m​,A(xn+m​)×B(xn+m​))}。 也就是说多项式乘法在点值表示法下可以 O(n)\\mathcal{O}(n)O(n) 计算，这启发我们设计如下算法来计算多项式乘法： 将 A(x)A(x)A(x) 和 B(x)B(x)B(x) 转为点值表示法。 在点值表示法下计算 A(x)A(x)A(x) 和 B(x)B(x)B(x) 的乘积 C(x)C(x)C(x)。 将 C(x)C(x)C(x) 转回系数表示法。 所以我们如果能够在较低的时间复杂度内将系数表示法转化为点值表示法，再将点值表示法转回系数表示法，就能以较低的时间复杂度计算多项式的乘法。 离散傅里叶变换 (DFT) 即令 x0=ωn0,x1=ωn1,⋯ ,xn−1=ωnn−1x_0 = \\omega_n ^ 0, x_1 = \\omega_n ^ 1, \\cdots, x_{n - 1} = \\omega_n ^ {n - 1}x0​=ωn0​,x1​=ωn1​,⋯,xn−1​=ωnn−1​ 代入多项式中得到的点值。 写成矩阵的形式就是： [111⋯11(ωn1)1(ωn1)2⋯(ωn1)n−11(ωn2)1(ωn2)2⋯(ωn2)n−1⋮⋮⋮⋱⋮1(ωnn−1)1(ωnn−1)2⋯(ωnn−1)n−1][a0a1a2⋮an−1]=[y0y1y2⋮yn−1]\\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ 1 &amp; (\\omega_n ^ 1) ^ 1 &amp; (\\omega_n ^ 1) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ 1) ^ {n - 1} \\\\ 1 &amp; (\\omega_n ^ 2) ^ 1 &amp; (\\omega_n ^ 2) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ 2) ^ {n - 1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; (\\omega_n ^ {n - 1}) ^ 1 &amp; (\\omega_n ^ {n - 1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 1}) ^ {n - 1} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n - 1} \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_{n - 1} \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎡​111⋮1​1(ωn1​)1(ωn2​)1⋮(ωnn−1​)1​1(ωn1​)2(ωn2​)2⋮(ωnn−1​)2​⋯⋯⋯⋱⋯​1(ωn1​)n−1(ωn2​)n−1⋮(ωnn−1​)n−1​⎦⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎡​a0​a1​a2​⋮an−1​​⎦⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎡​y0​y1​y2​⋮yn−1​​⎦⎥⎥⎥⎥⎥⎥⎤​ 其中 ωn\\omega_nωn​ 表示 nnn 次单位根，即 ωn=cos⁡2πn+isin⁡2πn\\omega_n = \\cos \\frac{2\\pi}{n} + i\\sin \\frac{2\\pi}{n}ωn​=cosn2π​+isinn2π​。 由欧拉公式可以得到 ωnk=cos⁡2kπn+isin⁡2kπn\\omega_n ^ k = \\cos \\frac{2k\\pi}{n} + i\\sin \\frac{2k\\pi}{n}ωnk​=cosn2kπ​+isinn2kπ​。 离散傅里叶逆变换 (IDFT) 为什么 DFT 中要代入单位根呢？自然有他的用处。 考虑将点值表示法转回系数表示法。 观察上述式子，我们只需在等式两边同时左乘一个单位根矩阵的逆即可。 通过范德蒙德矩阵求逆，我们得到： [111⋯11(ωn1)1(ωn1)2⋯(ωn1)n−11(ωn2)1(ωn2)2⋯(ωn2)n−1⋮⋮⋮⋱⋮1(ωnn−1)1(ωnn−1)2⋯(ωnn−1)n−1]−1=1n[111⋯11(ωnn−1)1(ωnn−1)2⋯(ωnn−1)n−11(ωnn−2)1(ωnn−2)2⋯(ωnn−2)n−1⋮⋮⋮⋱⋮1(ωn1)1(ωn1)2⋯(ωn1)n−1]\\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ 1 &amp; (\\omega_n ^ 1) ^ 1 &amp; (\\omega_n ^ 1) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ 1) ^ {n - 1} \\\\ 1 &amp; (\\omega_n ^ 2) ^ 1 &amp; (\\omega_n ^ 2) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ 2) ^ {n - 1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; (\\omega_n ^ {n - 1}) ^ 1 &amp; (\\omega_n ^ {n - 1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 1}) ^ {n - 1} \\end{bmatrix}^{-1} = \\dfrac{1}{n}\\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ 1 &amp; (\\omega_n ^ {n - 1}) ^ 1 &amp; (\\omega_n ^ {n - 1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 1}) ^ {n - 1} \\\\ 1 &amp; (\\omega_n ^ {n - 2}) ^ 1 &amp; (\\omega_n ^ {n - 2}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 2}) ^ {n - 1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; (\\omega_n ^ {1}) ^ 1 &amp; (\\omega_n ^ {1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {1}) ^ {n - 1} \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎡​111⋮1​1(ωn1​)1(ωn2​)1⋮(ωnn−1​)1​1(ωn1​)2(ωn2​)2⋮(ωnn−1​)2​⋯⋯⋯⋱⋯​1(ωn1​)n−1(ωn2​)n−1⋮(ωnn−1​)n−1​⎦⎥⎥⎥⎥⎥⎥⎤​−1=n1​⎣⎢⎢⎢⎢⎢⎢⎡​111⋮1​1(ωnn−1​)1(ωnn−2​)1⋮(ωn1​)1​1(ωnn−1​)2(ωnn−2​)2⋮(ωn1​)2​⋯⋯⋯⋱⋯​1(ωnn−1​)n−1(ωnn−2​)n−1⋮(ωn1​)n−1​⎦⎥⎥⎥⎥⎥⎥⎤​ 所以有： 1n[111⋯11(ωnn−1)1(ωnn−1)2⋯(ωnn−1)n−11(ωnn−2)1(ωnn−2)2⋯(ωnn−2)n−1⋮⋮⋮⋱⋮1(ωn1)1(ωn1)2⋯(ωn1)n−1][y0y1y2⋮yn−1]=[a0a1a2⋮an−1]\\dfrac{1}{n}\\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ 1 &amp; (\\omega_n ^ {n - 1}) ^ 1 &amp; (\\omega_n ^ {n - 1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 1}) ^ {n - 1} \\\\ 1 &amp; (\\omega_n ^ {n - 2}) ^ 1 &amp; (\\omega_n ^ {n - 2}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 2}) ^ {n - 1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; (\\omega_n ^ {1}) ^ 1 &amp; (\\omega_n ^ {1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {1}) ^ {n - 1} \\end{bmatrix} \\begin{bmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_{n - 1} \\end{bmatrix} = \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n - 1} \\end{bmatrix} n1​⎣⎢⎢⎢⎢⎢⎢⎡​111⋮1​1(ωnn−1​)1(ωnn−2​)1⋮(ωn1​)1​1(ωnn−1​)2(ωnn−2​)2⋮(ωn1​)2​⋯⋯⋯⋱⋯​1(ωnn−1​)n−1(ωnn−2​)n−1⋮(ωn1​)n−1​⎦⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎡​y0​y1​y2​⋮yn−1​​⎦⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎡​a0​a1​a2​⋮an−1​​⎦⎥⎥⎥⎥⎥⎥⎤​ 所以本质上 DFT 和 IDFT 可以用同样的方法来完成，只是代入的 xxx 值不同而已。 快速傅里叶变换 (FFT) 然而 DFT 的复杂度还是 O(n2)\\mathcal{O}(n ^ 2)O(n2)，能不能更快？ 考虑使用分治。 假设我们要将多项式 A(x)=a0+a1x+a2x2+⋯+an−1xn−1A(x) = a_0 + a_1x + a_2x ^ 2 + \\cdots + a_{n - 1}x ^ {n - 1}A(x)=a0​+a1​x+a2​x2+⋯+an−1​xn−1 转为点值表示法，我们按照下标奇偶性将 A(x)A(x)A(x) 中的项分为两部分，即： A(x)=a0+a2x2+a4x4+⋯+an−2xn−2+a1x+a3x3+a5x5+⋯+an−1xn−1\\begin{aligned} A(x) &amp;= a_0 + a_2x ^ 2 + a_4x ^ 4 + \\cdots + a_{n - 2}x^{n - 2} \\\\ &amp;+ a_1x + a_3x ^ 3 + a_5x ^ 5 + \\cdots + a_{n - 1}x^{n - 1} \\\\ \\end{aligned} A(x)​=a0​+a2​x2+a4​x4+⋯+an−2​xn−2+a1​x+a3​x3+a5​x5+⋯+an−1​xn−1​ 为了方便，我们假设 nnn 为 222 的幂次，这样子除以 222 时不会出现除不尽的情况。 我们设： Aeven(x)=a0+a2x+a4x2+⋯+an−2xn/2−1Aodd(x)=a1+a3x+a5x2+⋯+an−1xn/2−1\\begin{aligned} A_{\\text{even}}(x) = a_0 + a_2x + a_4x ^ 2 + \\cdots + a_{n - 2}x^{n / 2 - 1} \\\\ A_{\\text{odd}}(x) = a_1 + a_3x + a_5x ^ 2 + \\cdots + a_{n - 1}x^{n / 2 - 1} \\end{aligned} Aeven​(x)=a0​+a2​x+a4​x2+⋯+an−2​xn/2−1Aodd​(x)=a1​+a3​x+a5​x2+⋯+an−1​xn/2−1​ 所以有： A(x)=Aeven(x2)+xAodd(x2)A(x) = A_{\\text{even}}(x ^ 2) + xA_{\\text{odd}}(x ^ 2) A(x)=Aeven​(x2)+xAodd​(x2) 划分好之后，我们尝试代入 x=ωnk (k&lt;n2)x = \\omega_n^k\\ (k \\lt \\dfrac{n}{2})x=ωnk​ (k&lt;2n​)： A(x)=Aeven(ωn2k)+ωnkAodd(ωn2k)=Aeven(ωn2k)+ωnkAodd(ωn2k)\\begin{aligned} A(x) &amp;= A_{\\text{even}}(\\omega_n^{2k}) + \\omega_n^kA_{\\text{odd}}(\\omega_n^{2k}) \\\\ &amp;= A_{\\text{even}}(\\omega_{\\frac{n}{2}}^{k}) + \\omega_n^kA_{\\text{odd}}(\\omega_{\\frac{n}{2}}^{k})\\\\ \\end{aligned} A(x)​=Aeven​(ωn2k​)+ωnk​Aodd​(ωn2k​)=Aeven​(ω2n​k​)+ωnk​Aodd​(ω2n​k​)​ 继续代入 x=ωnk+n2 (k&lt;n2)x = \\omega_n^{k + \\frac{n}{2}}\\ (k \\lt \\dfrac{n}{2})x=ωnk+2n​​ (k&lt;2n​)： A(x)=Aeven(ωn2k+n)+ωnk+n2Aodd(ωn2k+n)=Aeven(ωn2k)−ωnkAodd(ωn2k)=Aeven(ωn2k)−ωnkAodd(ωn2k)\\begin{aligned} A(x) &amp;= A_{\\text{even}}(\\omega_n^{2k + n}) + \\omega_n^{k + \\frac{n}{2}}A_{\\text{odd}}(\\omega_n^{2k + n}) \\\\ &amp;= A_{\\text{even}}(\\omega_n^{2k}) - \\omega_n^kA_{\\text{odd}}(\\omega_n^{2k}) \\\\ &amp;= A_{\\text{even}}(\\omega_{\\frac{n}{2}}^{k}) - \\omega_n^kA_{\\text{odd}}(\\omega_{\\frac{n}{2}}^{k})\\\\ \\end{aligned} A(x)​=Aeven​(ωn2k+n​)+ωnk+2n​​Aodd​(ωn2k+n​)=Aeven​(ωn2k​)−ωnk​Aodd​(ωn2k​)=Aeven​(ω2n​k​)−ωnk​Aodd​(ω2n​k​)​ 由于单位根的奇妙性质，两式仅有一个正负号不同，于是对于每个 k∈[1,n2−1]k \\in [1, \\dfrac{n}{2} - 1]k∈[1,2n​−1]，我们只需求 Aeven(ωn2k)A_{\\text{even}}(\\omega_{\\frac{n}{2}}^{k})Aeven​(ω2n​k​) 和 Aodd(ωn2k)A_{\\text{odd}}(\\omega_{\\frac{n}{2}}^{k})Aodd​(ω2n​k​) 的值即可算出 A(ωnk)A(\\omega_n^k)A(ωnk​) 和 A(ωnk+n2)A(\\omega_n^{k + \\frac{n}{2}})A(ωnk+2n​​)。 而 AevenA_{\\text{even}}Aeven​ 和 AoddA_{\\text{odd}}Aodd​ 是两个规模减半的子问题，可以递归计算。 时间复杂度 T(n)=2T(n2)+O(n)=O(nlog⁡n)T(n) = 2T(\\frac{n}{2}) + \\mathcal{O}(n) = \\mathcal{O}(n \\log n)T(n)=2T(2n​)+O(n)=O(nlogn)。 逆变换也是类似，注意到 ωnk\\omega_n^{k}ωnk​ 与 ωnn−k\\omega_n^{n - k}ωnn−k​ 互为共轭，所以只需要在单位根的虚部处加一个负号即可。 在实现时，可以将 FFT 和 IFFT 放在同个函数内实现，当 inv = 1 时为 FFT，inv = -1 时为 IFFT，减小码量。 Complex 类自己手写会快一点。 Code1234567891011121314151617181920212223242526272829303132struct Complex { double a, b; // a + b * i Complex() {} Complex(double _a, double _b) { a = _a; b = _b; } Complex operator + (Complex const &amp;rhs) const { return Complex(a + rhs.a, b + rhs.b); } Complex operator - (Complex const &amp;rhs) const { return Complex(a - rhs.a, b - rhs.b); } Complex operator * (Complex const &amp;rhs) const { return Complex(a * rhs.a - b * rhs.b, a * rhs.b + b * rhs.a); }};void FFT(vector&lt;Complex&gt; &amp;A, int n, int inv) { if(n == 1) return; vector&lt;Complex&gt; e(n / 2), o(n / 2); for(int i = 0; i &lt; n; i += 2) { e[i / 2] = A[i]; o[i / 2] = A[i + 1]; } FFT(e, n / 2, inv); FFT(o, n / 2, inv); Complex wn(cos(2 * PI / n), inv * sin(2 * PI / n)), wk(1, 0); for(int i = 0; i &lt; n / 2; i++, wk = wk * wn) { A[i] = e[i] + wk * o[i]; A[i + len / 2] = e[i] - wk * o[i]; }} 三次变两次优化 假设我们要求 A(x)∗B(x)A(x) * B(x)A(x)∗B(x)，我们设复多项式 P(x)=A(x)+B(x)iP(x) = A(x) + B(x)iP(x)=A(x)+B(x)i，也就是 PPP 的实部为 AAA，虚部为 BBB。 则有 P(x)2=A(x)2−B(x)2+2A(x)∗B(x)iP(x)^2 = A(x)^2 - B(x)^2 + 2A(x)*B(x)iP(x)2=A(x)2−B(x)2+2A(x)∗B(x)i，所以我们把 B(x)B(x)B(x) 的系数放到虚部上，然后求出 P(x)2P(x)^2P(x)2，将其虚部除以 222 即可。 这样一来我们只需用对 PPP 做一次 FFT 和一次 IFFT，常数是原来的 23\\dfrac{2}{3}32​。 完整代码（省略 FastIO）: Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define i64 long long #define all(x) x.begin(), x.end()#define seg(a, l, r) a + l, a + r + 1#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)using namespace std;using namespace FastIO;const int N = 1e6 + 5;const double PI = acos(-1.0), EPS = 1e-8;struct Complex { double a, b; // a + b * i Complex() {} Complex(double _a, double _b) { a = _a; b = _b; } Complex operator + (Complex const &amp;rhs) const { return Complex(a + rhs.a, b + rhs.b); } Complex operator - (Complex const &amp;rhs) const { return Complex(a - rhs.a, b - rhs.b); } Complex operator * (Complex const &amp;rhs) const { return Complex(a * rhs.a - b * rhs.b, a * rhs.b + b * rhs.a); }};int n, m;vector&lt;Complex&gt; a;void FFT(vector&lt;Complex&gt; &amp;arr, int len, int inv) { if(len == 1) return; vector&lt;Complex&gt; e(len / 2), o(len / 2); for(int i = 0; i &lt; len; i += 2) { e[i / 2] = arr[i]; o[i / 2] = arr[i + 1]; } FFT(e, len / 2, inv); FFT(o, len / 2, inv); Complex wn(cos(2 * PI / len), inv * sin(2 * PI / len)), wk(1, 0); for(int i = 0; i &lt; len / 2; i++, wk = wk * wn) { Complex val = wk * o[i]; arr[i] = e[i] + val; arr[i + len / 2] = e[i] - val; }}int main() { read(n); read(m); int len = 1; while(len &lt; n + m + 1) len *= 2; a.resize(len); rep(i, 0, n) { int x; read(x); a[i].a = x; } rep(i, 0, m) { int x; read(x); a[i].b = x; } FFT(a, len, 1); rep(i, 0, len - 1) a[i] = a[i] * a[i]; FFT(a, len, -1); rep(i, 0, n + m) writesp((int)round(a[i].b / 2 / len + EPS)); return flush(), 0;}","link":"/2023/10/15/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Tarjan 全家桶","text":"部分定义摘自 Alex_Wei 的博客，如有侵权，请联系笔者删除。 割点 在无向图中，删去后使得连通分量数增加的结点称为割点。 孤立点不是割点。 非根节点 uuu 为割点当且仅当 dfs 树上存在一条树边 u→vu \\rightarrow vu→v 使得 low⁡v≥dfn⁡u\\operatorname{low}_v \\geq \\operatorname{dfn}_ulowv​≥dfnu​。 根节点 uuu 为割点当且仅当 dfs 树上 uuu 有两个以上的子节点。 割点12345678910111213141516171819void tarjan(int u, int last, bool isRoot) { dfn[u] = low[u] = ++timer; int son = 0; for(int i = head[u]; ~i; i = E[i].nxt) { if(i == (last ^ 1)) continue; int v = E[i].v; if(!dfn[v]) { son++; tarjan(v, i, false); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u] &amp;&amp; !isRoot) isCut[u] = true; } else low[u] = min(low[u], dfn[v]); } if(isRoot &amp;&amp; son &gt;= 2) isCut[u] = true;} 点双连通分量 点双连通图：不存在割点的无向连通图称为点双连通图，孤立点和孤立边均为点双连通图。 点双连通分量：一张图的极大点双连通子图称为点双连通分量（V-BCC），简称点双。 性质 两个点双至多存在一个公共点（该点一定是割点）。 任意一个非割点的点都只存在于一个点双中，割点一定属于两个及以上的点双。 对于一个点双（除去孤立边），其内部任意两不同点一定存在两条及以上的点不重复的路径。 实现 我们需要在 Tarjan 算法的过程中维护一个栈，并按照如下方法维护栈中的元素： 当一个节点第一次被访问时，将该节点入栈。 当遍历到一条树边 u→vu \\rightarrow vu→v 满足 low⁡v≥dfn⁡u\\operatorname{low}_v \\geq \\operatorname{dfn}_ulowv​≥dfnu​ 时（此时 uuu 为割点），不断弹出栈内元素直至节点 vvv 被弹出，所有被弹出的节点（以及节点 uuu）即为一个新的点双连通分量。 注意在弹栈的时候不能把节点 uuu 弹出，因为 uuu 可能属于多个点双。 点双连通分量123456789101112131415161718192021222324252627282930313233void tarjan(int u, int last, bool isRoot) { dfn[u] = low[u] = ++timer; s.push(u); int son = 0; for(int i = head[u]; ~i; i = E[i].nxt) { if(i == (last ^ 1)) continue; int v = E[i].v; if(!dfn[v]) { son++; tarjan(v, i, false); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]) { vBCC_cnt++; int p = 0; do { p = s.top(); s.pop(); vBCC[vBCC_cnt].push_back(p); } while(p != v); vBCC[vBCC_cnt].push_back(u); } } else low[u] = min(low[u], dfn[v]); } if(isRoot &amp;&amp; !son) { // 特判孤立点 vBCC_cnt++; vBCC[vBCC_cnt].push_back(u); }} 割边 在无向图中，删去后使得连通分量数增加的边称为割边，也称桥。 孤立边是割边。 一条边 u→vu \\rightarrow vu→v 是割边当且仅当： u→vu \\rightarrow vu→v 是 dfs 树的树边。 low⁡v&gt;dfn⁡u\\operatorname{low}_v \\gt \\operatorname{dfn}_ulowv​&gt;dfnu​。 割边1234567891011121314151617void tarjan(int u, int last) { dfn[u] = low[u] = ++timer; for(int i = head[u]; ~i; i = E[i].nxt) { if(i == (last ^ 1)) continue; int v = E[i].v; if(!dfn[v]) { tarjan(v, i); low[u] = min(low[u], low[v]); if(low[v] &gt; dfn[u]) isBridge[i] = isBridge[i ^ 1] = true; } else low[u] = min(low[u], dfn[v]); }} 边双连通分量 边双连通图：不存在割边的无向连通图称为边双连通图。孤立点是边双连通图，但孤立边不是。 边双连通分量：一张图的极大边双连通子图称为边双连通分量（E-BCC），简称边双。 实现 删去所有割边后，剩下的连通分量即为边双连通分量。 边双连通分量1234567891011void dfs(int u) { vis[u] = true; eBCC[eBCC_cnt].push_back(u); for(int i = head[u]; ~i; i = E[i].nxt) { if(isBridge[i]) continue; int v = E[i].v; if(!vis[v]) dfs(v); }} 强连通分量 定义一个强连通分量的根为该强连通分量中最浅的节点。 那么节点 uuu 为它所在强连通分量的根当且仅当 dfn⁡u=low⁡u\\operatorname{dfn}_u = \\operatorname{low}_udfnu​=lowu​。 实现 同样需要维护一个栈，并按照如下方法维护栈中的元素： 当一个节点第一次被访问时，将该节点入栈。 当点 uuu 满足 dfn⁡u=low⁡u\\operatorname{dfn}_u = \\operatorname{low}_udfnu​=lowu​ 时，不断弹出栈内元素直至 uuu 被弹出，所有被弹出的节点即为一个强连通分量。 注意如果遍历到一个已经访问过的点 vvv，只有在栈内的 vvv 才能用来更新 low⁡u\\operatorname{low}_ulowu​。 强连通分量12345678910111213141516171819202122232425void tarjan(int u) { dfn[u] = low[u] = ++timer; s.push(u); inStack[u] = true; for(int i = head[u]; ~i; i = E[i].nxt) { int v = E[i].v; if(!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if(inStack[v]) low[u] = min(low[u], dfn[v]); } if(dfn[u] == low[u]) { SCC_cnt++; while(s.top() != u) { SCC[SCC_cnt].push_back(s.top()); inStack[s.top()] = false; s.pop(); } SCC[SCC_cnt].push_back(u); inStack[u] = false; s.pop(); }}","link":"/2023/10/18/Tarjan-%E5%85%A8%E5%AE%B6%E6%A1%B6/"},{"title":"眼前一亮思维题","text":"题目来源于这个题单，码量较少，而且不会出现非常复杂的数学推导，十分适合锻炼思维。 P5875 [IOI2014] friend 朋友 给定一张 nnn 个点的无向图，初始只有一个点 000，从 111 到 n−1n - 1n−1 依次加入点，每次加入点 iii 时有三种选择： 给定 jjj，将 iii 与 jjj 连边； 给定 jjj，将 iii 与 jjj 的所有邻居连边； 给定 jjj，将 iii 与 jjj 和 jjj 的所有邻居连边。 n≤105n\\leq 10 ^ 5n≤105，求该图的最大权独立集。 Sol: 神题，完全没有思路，想了 20min 就看题解了。 令 aia_iai​ 为点 iii 的权值。 发现正着来不好搞，会有后效性，所以考虑倒着删去每个点。 对于第一种连边方式，我们将答案加上 aia_iai​，不难发现 aj&lt;aia_j &lt; a_iaj​&lt;ai​ 时一定不会选择 aja_jaj​，所以我们让 aj←max⁡(0,aj−ai)a_j \\leftarrow \\max(0, a_j - a_i)aj​←max(0,aj​−ai​)。 对于第二种连边方式，iii 和 jjj 一定是同时选或同时不选，所以我们让 aj←aj+aia_j \\leftarrow a_j + a_iaj​←aj​+ai​，把选择权交给 jjj。 对于第三种连边方式，iii 和 jjj 的邻居是相同的，也就是说这两个点是等价的，如果要选肯定是选权值大的那一个，所以我们让 aj←max⁡(aj,ai)a_j \\leftarrow \\max(a_j, a_i)aj​←max(aj​,ai​)。 最后答案即为 ans+a0ans + a_0ans+a0​。 Code123456789101112131415i64 a[N];int findSample(int n, int confidence[], int host[], int protocol[]) { i64 ans = 0; rep(i, 0, n - 1) a[i] = confidence[i]; per(i, n - 1, 1) { if(protocol[i] == 0) ans += a[i], a[host[i]] = max(a[host[i]] - a[i], 0ll); if(protocol[i] == 1) a[host[i]] += a[i]; if(protocol[i] == 2) a[host[i]] = max(a[host[i]], a[i]); } return ans + a[0];} P3599 Koishi Loves Construction 给定正整数 n (1≤n≤105)n\\ (1\\leq n \\leq 10 ^ 5)n (1≤n≤105)，有以下两个任务： 判断并构造一个长度为 nnn 的 1∼n1\\sim n1∼n 的排列，满足其 nnn 个前缀和在模 nnn 的意义下互不相同。 判断并构造一个长度为 nnn 的 1∼n1\\sim n1∼n 的排列，满足其 nnn 个前缀积在模 nnn 的意义下互不相同。 Sol: 这题在写它之前已经见过好多遍了，所以没怎么想就切了。 对于任务 111，首先我们必须把 nnn 放在第一个，否则一定会出现两个前缀和模 nnn 相同。 然后不难发现，当 nnn 为奇数时，总和为 n×(n−1)2≡0(modn)n\\times \\dfrac{(n - 1)}{2} \\equiv 0\\pmod nn×2(n−1)​≡0(modn)，这样无论如何都会有两个前缀和模 nnn 相同，所以无解。 对于 nnn 为偶数的情况，我们尝试构造 a={0,1,−2,3,−4,⋯ }a = \\{0, 1, -2, 3, -4, \\cdots\\}a={0,1,−2,3,−4,⋯}（模意义下），这样前缀和就是 s={0,1,−1,2,−2,⋯ }s = \\{0, 1, -1, 2, -2,\\cdots\\}s={0,1,−1,2,−2,⋯}，满足互不相同。 对于任务 222，不难得出 nnn 必须要放在最后一个，而当 nnn 为合数时存在 p,qp,qp,q，使得 p×q≡0(modn)p\\times q\\equiv 0 \\pmod np×q≡0(modn)，所以必然无解。 对于 nnn 为质数的情况，构造 a={1,21,32,43,⋯ }a=\\{1,\\dfrac{2}{1},\\dfrac{3}{2},\\dfrac{4}{3},\\cdots\\}a={1,12​,23​,34​,⋯}（模意义下），这样前缀积即为 p={1,2,3,4,⋯ }p=\\{1,2,3,4,\\cdots\\}p={1,2,3,4,⋯}，满足互不相同。 求出 1∼n−11\\sim n - 11∼n−1 在模 nnn 意义下的逆元即可，复杂度 O(n)\\mathcal{O}(n)O(n)。 注意特判，n=1n=1n=1 时两个任务均有解 a={1}a=\\{1\\}a={1}，n=4n=4n=4 时对于任务 222 有解 a={1,3,2,4}a=\\{1,3,2,4\\}a={1,3,2,4}。 Code12345678910111213141516171819202122232425void task1() { if(n == 1) cout &lt;&lt; &quot;1&quot; &lt;&lt; &quot;\\n&quot;; else if(n % 2 == 1) cout &lt;&lt; &quot;No&quot; &lt;&lt; &quot;\\n&quot;; else { rep(i, 0, n - 1) { int val = (i % 2 == 0 ? i : -i); cout &lt;&lt; (val &gt; 0 ? val : val + n) &lt;&lt; &quot; &quot;; } cout &lt;&lt; &quot;\\n&quot;; }}void task2() { if(n == 1) cout &lt;&lt; &quot;1&quot; &lt;&lt; &quot;\\n&quot;; else if(n == 4) cout &lt;&lt; &quot;1 3 2 4&quot; &lt;&lt; &quot;\\n&quot;; else if(isPrime(n)) { inv[1] = 1; rep(i, 2, n - 1) inv[i] = 1ll * (n - n / i) * inv[n % i] % n; cout &lt;&lt; 1 &lt;&lt; &quot;\\n&quot;; rep(i, 2, n - 1) cout &lt;&lt; 1ll * i * inv[i - 1] % n &lt;&lt; &quot; &quot;; cout &lt;&lt; n &lt;&lt; &quot;\\n&quot;; } else cout &lt;&lt; &quot;No&quot; &lt;&lt; &quot;\\n&quot;;} P6137 [IOI2012] 理想城 无限大的网格上有两种格子，其中 n (1≤n≤105)n\\ (1\\leq n \\leq 10 ^ 5)n (1≤n≤105) 个是黄格子，其余的都是白格子，满足所有黄格子四联通，所有白格子四联通。 现给定这 nnn 个黄格子的坐标，求出每两个黄格子之间的最短路长度之和。","link":"/2023/10/27/%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E6%80%9D%E7%BB%B4%E9%A2%98/"}],"tags":[{"name":"OI Problem","slug":"OI-Problem","link":"/tags/OI-Problem/"},{"name":"OI Note","slug":"OI-Note","link":"/tags/OI-Note/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"}],"categories":[],"pages":[]}