{"posts":[{"title":"Tarjan 全家桶","text":"部分定义摘自 Alex_Wei 的博客，如有侵权，请联系笔者删除。 割点 在无向图中，删去后使得连通分量数增加的结点称为割点。 孤立点不是割点。 非根节点 uuu 为割点当且仅当 dfs 树上存在一条树边 u→vu \\rightarrow vu→v 使得 low⁡v≥dfn⁡u\\operatorname{low}_v \\geq \\operatorname{dfn}_ulowv​≥dfnu​。 根节点 uuu 为割点当且仅当 dfs 树上 uuu 有两个以上的子节点。 12345678910111213141516171819void tarjan(int u, int last, bool isRoot) { dfn[u] = low[u] = ++timer; int son = 0; for(int i = head[u]; ~i; i = E[i].nxt) { if(i == (last ^ 1)) continue; int v = E[i].v; if(!dfn[v]) { son++; tarjan(v, i, false); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u] &amp;&amp; !isRoot) isCut[u] = true; } else low[u] = min(low[u], dfn[v]); } if(isRoot &amp;&amp; son &gt;= 2) isCut[u] = true;} 点双连通分量 点双连通图：不存在割点的无向连通图称为点双连通图，孤立点和孤立边均为点双连通图。 点双连通分量：一张图的极大点双连通子图称为点双连通分量（V-BCC），简称点双。 性质 两个点双至多存在一个公共点（该点一定是割点）。 任意一个非割点的点都只存在于一个点双中，割点一定属于两个及以上的点双。 对于一个点双（除去孤立边），其内部任意两不同点一定存在两条及以上的点不重复的路径。 求法 我们需要在 Tarjan 算法的过程中维护一个栈，并按照如下方法维护栈中的元素： 当一个节点第一次被访问时，将该节点入栈。 当遍历到一条树边 u→vu \\rightarrow vu→v 满足 low⁡v≥dfn⁡u\\operatorname{low}_v \\geq \\operatorname{dfn}_ulowv​≥dfnu​ 时（此时 uuu 为割点），不断弹出栈内元素直至节点 vvv 被弹出，所有被弹出的节点（以及节点 uuu）即为一个新的点双连通分量。 注意在弹栈的时候不能把节点 uuu 弹出，因为 uuu 可能属于多个点双。 123456789101112131415161718192021222324252627282930313233void tarjan(int u, int last, bool isRoot) { dfn[u] = low[u] = ++timer; s.push(u); int son = 0; for(int i = head[u]; ~i; i = E[i].nxt) { if(i == (last ^ 1)) continue; int v = E[i].v; if(!dfn[v]) { son++; tarjan(v, i, false); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]) { vBCC_cnt++; int p = 0; do { p = s.top(); s.pop(); vBCC[vBCC_cnt].push_back(p); } while(p != v); vBCC[vBCC_cnt].push_back(u); } } else low[u] = min(low[u], dfn[v]); } if(isRoot &amp;&amp; !son) { // 特判孤立点 vBCC_cnt++; vBCC[vBCC_cnt].push_back(u); }} 割边 在无向图中，删去后使得连通分量数增加的边称为割边，也称桥。 孤立边是割边。 一条边 u→vu \\rightarrow vu→v 是割边当且仅当： u→vu \\rightarrow vu→v 是 dfs 树的树边。 low⁡v&gt;dfn⁡u\\operatorname{low}_v \\gt \\operatorname{dfn}_ulowv​&gt;dfnu​。 1234567891011121314151617void tarjan(int u, int last) { dfn[u] = low[u] = ++timer; for(int i = head[u]; ~i; i = E[i].nxt) { if(i == (last ^ 1)) continue; int v = E[i].v; if(!dfn[v]) { tarjan(v, i); low[u] = min(low[u], low[v]); if(low[v] &gt; dfn[u]) isBridge[i] = isBridge[i ^ 1] = true; } else low[u] = min(low[u], dfn[v]); }}","link":"/2023/10/18/Tarjan-%E5%85%A8%E5%AE%B6%E6%A1%B6/"},{"title":"dfs 序求 LCA","text":"O(nlog⁡n)−O(1)\\mathcal{O}(n\\log n) - \\mathcal{O}(1)O(nlogn)−O(1) 求 LCA 的科技！ 考虑对一棵树进行 dfs 的过程，对于两个点 u,vu, vu,v（不妨设 dfn⁡u&lt;dfn⁡v\\operatorname{dfn}_u \\lt \\operatorname{dfn}_vdfnu​&lt;dfnv​），dfs 时，我们总是先从 lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v) 下到 uuu 点，再回到 lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v)，然后再下到 vvv 点。 我们发现，总有一个 lca(u,v)⁡\\operatorname{lca(u, v)}lca(u,v) 的儿子，它的 dfn⁡\\operatorname{dfn}dfn 是落在 [dfn⁡u,dfn⁡v][\\operatorname{dfn}_u, \\operatorname{dfn}_v][dfnu​,dfnv​] 之间的（考虑从 lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v) 下到 vvv 点的过程，总会经过它到 vvv 这条链上的儿子）。 而 dfn⁡\\operatorname{dfn}dfn 在 [dfn⁡u,dfn⁡v][\\operatorname{dfn}_u, \\operatorname{dfn}_v][dfnu​,dfnv​] 之间的所有点的深度都不会小于或等于 lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v)。 于是我们只需要找到 dfn⁡\\operatorname{dfn}dfn 在 [dfn⁡u,dfn⁡v][\\operatorname{dfn}_u, \\operatorname{dfn}_v][dfnu​,dfnv​] 之间的深度最小的点即可，lca⁡(u,v)\\operatorname{lca}(u, v)lca(u,v) 即为该点的父亲。 发现 uuu 是 vvv 的祖先时会出问题，我们令查询区间从 [dfn⁡u,dfn⁡v][\\operatorname{dfn}_u, \\operatorname{dfn}_v][dfnu​,dfnv​] 变为 [dfn⁡u+1,dfn⁡v][\\operatorname{dfn}_u + 1, \\operatorname{dfn}_v][dfnu​+1,dfnv​] 即可，不会影响先前的结论。 使用 ST 表可以做到 O(nlog⁡n)−O(1)\\mathcal{O}(n\\log n) - \\mathcal{O}(1)O(nlogn)−O(1)。 Code:\\large\\textbf{Code:}Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define i64 long long#define all(x) x.begin(), x.end()#define seg(a, l, r) a + l, a + r + 1#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)using namespace std;const int N = 5e5 + 5, M = 5e5 + 5, LOG = 20;struct Edge { int u, v, nxt; Edge() {} Edge(int _u, int _v, int _nxt) { u = _u; v = _v; nxt = _nxt; }} E[M &lt;&lt; 1];int n, m, root, tot, timer;int head[N], dfn[N], dep[N], fa[N], lg2[N];int stLCA[LOG][N];void addEdge(int u, int v) { E[tot] = Edge(u, v, head[u]); head[u] = tot++;}void dfs(int u, int f) { dfn[u] = ++timer; dep[u] = dep[f] + 1; fa[u] = f; stLCA[0][dfn[u]] = u; for(int i = head[u]; ~i; i = E[i].nxt) { int v = E[i].v; if(v == f) continue; dfs(v, u); }}int get(int u, int v) { return dep[u] &lt; dep[v] ? u : v;}int LCA(int u, int v) { if(u == v) return u; if(dfn[u] &gt; dfn[v]) swap(u, v); u = dfn[u] + 1, v = dfn[v]; int k = lg2[v - u + 1]; return fa[get(stLCA[k][u], stLCA[k][v - (1 &lt;&lt; k) + 1])];}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(head, -1, sizeof(head)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; root; lg2[1] = 0; rep(i, 2, n) lg2[i] = lg2[i &gt;&gt; 1] + 1; rep(i, 1, n - 1) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, v); addEdge(v, u); } dfs(root, 0); rep(j, 1, lg2[n]) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) stLCA[j][i] = get(stLCA[j - 1][i], stLCA[j - 1][i + (1 &lt;&lt; j - 1)]); while(m--) { int u, v; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; LCA(u, v) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/10/15/dfs-%E5%BA%8F%E6%B1%82-LCA/"},{"title":"快速傅里叶变换 (FFT) 学习笔记","text":"多项式 对于一个 n+1n + 1n+1 次多项式 A(x)=a0+a1x+a2x2+⋯+anxnA(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_{n} x ^ {n}A(x)=a0​+a1​x+a2​x2+⋯+an​xn，有以下两种表示方法： 系数表示： 由上文提到的 (a0,a1,a2,⋯ ,an)(a_0, a_1, a_2, \\cdots, a_{n})(a0​,a1​,a2​,⋯,an​) 这 n+1n + 1n+1 个系数来表示一个 nnn 次多项式。 点值表示： 由 (x0,y0),(x1,y1),⋯ ,(xn,yn)(x_0, y_0), (x_1, y_1), \\cdots, (x_{n}, y_{n})(x0​,y0​),(x1​,y1​),⋯,(xn​,yn​) 这 n+1n + 1n+1 个点来表示一个 nnn 次多项式，其中对于 ∀i∈[0,n]\\forall i \\in [0, n]∀i∈[0,n]，有 yi=A(xi)y_i = A(x_i)yi​=A(xi​)。 所以一个多项式也可以被写作 {(x0,A(x0)),(x1,A(x1)),⋯ ,(xn,A(xn))}\\{(x_0, A(x_0)), (x_1, A(x_1)), \\cdots, (x_{n}, A(x_{n}))\\}{(x0​,A(x0​)),(x1​,A(x1​)),⋯,(xn​,A(xn​))}。 多项式卷积 / 乘法 对于两个多项式 A(x),B(x)A(x), B(x)A(x),B(x)，定义卷积运算 A(x)∗B(x)=C(x)A(x) * B(x) = C(x)A(x)∗B(x)=C(x)，其中 C(x)C(x)C(x) 满足 ck=∑i⊕j=kaibjc_k = \\sum\\limits_{i \\oplus j = k} a_ib_jck​=i⊕j=k∑​ai​bj​。 这里的 ⊕\\oplus⊕ 符号表示某种二元运算符，当 ⊕\\oplus⊕ 为加法操作时即为常见的多项式乘法。 所以显然我们可以使用如下代码计算两个多项式乘法的结果： 12345678vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) { int n = A.size(), m = B.size(); vector&lt;int&gt; C(n + m - 1, 0); rep(i, 0, n - 1) rep(j, 0, m - 1) C[i + j] += A[i] * B[j]; return C;} 时间复杂度为 O(n2)\\mathcal{O}(n ^ 2)O(n2)。 点值表示法的优势 系数表示法固然很方便，但是在进行多项式乘法时，点值表示法的优势就体现出来了。 考虑由 A(x)A(x)A(x) 和 B(x)B(x)B(x) 的点值表示法计算出 C(x)C(x)C(x) 的点值表示法。 则 C(x)C(x)C(x) 即为 {(x0,A(x0)×B(x0)),(x1,A(x1)×B(x1)),⋯ ,(xn+m,A(xn+m)×B(xn+m))}\\{(x_0, A(x_0) \\times B(x_0)), (x_1, A(x_1) \\times B(x_1)), \\cdots, (x_{n + m}, A(x_{n + m}) \\times B(x_{n + m}))\\}{(x0​,A(x0​)×B(x0​)),(x1​,A(x1​)×B(x1​)),⋯,(xn+m​,A(xn+m​)×B(xn+m​))}。 也就是说多项式乘法在点值表示法下可以 O(n)\\mathcal{O}(n)O(n) 计算，这启发我们设计如下算法来计算多项式乘法： 将 A(x)A(x)A(x) 和 B(x)B(x)B(x) 转为点值表示法。 在点值表示法下计算 A(x)A(x)A(x) 和 B(x)B(x)B(x) 的乘积 C(x)C(x)C(x)。 将 C(x)C(x)C(x) 转回系数表示法。 所以我们如果能够在较低的时间复杂度内将系数表示法转化为点值表示法，再将点值表示法转回系数表示法，就能以较低的时间复杂度计算多项式的乘法。 离散傅里叶变换 (DFT) 即令 x0=ωn0,x1=ωn1,⋯ ,xn−1=ωnn−1x_0 = \\omega_n ^ 0, x_1 = \\omega_n ^ 1, \\cdots, x_{n - 1} = \\omega_n ^ {n - 1}x0​=ωn0​,x1​=ωn1​,⋯,xn−1​=ωnn−1​ 代入多项式中得到的点值。 写成矩阵的形式就是： [111⋯11(ωn1)1(ωn1)2⋯(ωn1)n−11(ωn2)1(ωn2)2⋯(ωn2)n−1⋮⋮⋮⋱⋮1(ωnn−1)1(ωnn−1)2⋯(ωnn−1)n−1][a0a1a2⋮an−1]=[y0y1y2⋮yn−1]\\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ 1 &amp; (\\omega_n ^ 1) ^ 1 &amp; (\\omega_n ^ 1) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ 1) ^ {n - 1} \\\\ 1 &amp; (\\omega_n ^ 2) ^ 1 &amp; (\\omega_n ^ 2) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ 2) ^ {n - 1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; (\\omega_n ^ {n - 1}) ^ 1 &amp; (\\omega_n ^ {n - 1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 1}) ^ {n - 1} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n - 1} \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_{n - 1} \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎡​111⋮1​1(ωn1​)1(ωn2​)1⋮(ωnn−1​)1​1(ωn1​)2(ωn2​)2⋮(ωnn−1​)2​⋯⋯⋯⋱⋯​1(ωn1​)n−1(ωn2​)n−1⋮(ωnn−1​)n−1​⎦⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎡​a0​a1​a2​⋮an−1​​⎦⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎡​y0​y1​y2​⋮yn−1​​⎦⎥⎥⎥⎥⎥⎥⎤​ 其中 ωn\\omega_nωn​ 表示 nnn 次单位根，即 ωn=cos⁡2πn+isin⁡2πn\\omega_n = \\cos \\frac{2\\pi}{n} + i\\sin \\frac{2\\pi}{n}ωn​=cosn2π​+isinn2π​。 由欧拉公式可以得到 ωnk=cos⁡2kπn+isin⁡2kπn\\omega_n ^ k = \\cos \\frac{2k\\pi}{n} + i\\sin \\frac{2k\\pi}{n}ωnk​=cosn2kπ​+isinn2kπ​。 离散傅里叶逆变换 (IDFT) 为什么 DFT 中要代入单位根呢？自然有他的用处。 考虑将点值表示法转回系数表示法。 观察上述式子，我们只需在等式两边同时左乘一个单位根矩阵的逆即可。 通过范德蒙德矩阵求逆，我们得到： [111⋯11(ωn1)1(ωn1)2⋯(ωn1)n−11(ωn2)1(ωn2)2⋯(ωn2)n−1⋮⋮⋮⋱⋮1(ωnn−1)1(ωnn−1)2⋯(ωnn−1)n−1]−1=1n[111⋯11(ωnn−1)1(ωnn−1)2⋯(ωnn−1)n−11(ωnn−2)1(ωnn−2)2⋯(ωnn−2)n−1⋮⋮⋮⋱⋮1(ωn1)1(ωn1)2⋯(ωn1)n−1]\\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ 1 &amp; (\\omega_n ^ 1) ^ 1 &amp; (\\omega_n ^ 1) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ 1) ^ {n - 1} \\\\ 1 &amp; (\\omega_n ^ 2) ^ 1 &amp; (\\omega_n ^ 2) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ 2) ^ {n - 1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; (\\omega_n ^ {n - 1}) ^ 1 &amp; (\\omega_n ^ {n - 1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 1}) ^ {n - 1} \\end{bmatrix}^{-1} = \\dfrac{1}{n}\\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ 1 &amp; (\\omega_n ^ {n - 1}) ^ 1 &amp; (\\omega_n ^ {n - 1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 1}) ^ {n - 1} \\\\ 1 &amp; (\\omega_n ^ {n - 2}) ^ 1 &amp; (\\omega_n ^ {n - 2}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 2}) ^ {n - 1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; (\\omega_n ^ {1}) ^ 1 &amp; (\\omega_n ^ {1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {1}) ^ {n - 1} \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎡​111⋮1​1(ωn1​)1(ωn2​)1⋮(ωnn−1​)1​1(ωn1​)2(ωn2​)2⋮(ωnn−1​)2​⋯⋯⋯⋱⋯​1(ωn1​)n−1(ωn2​)n−1⋮(ωnn−1​)n−1​⎦⎥⎥⎥⎥⎥⎥⎤​−1=n1​⎣⎢⎢⎢⎢⎢⎢⎡​111⋮1​1(ωnn−1​)1(ωnn−2​)1⋮(ωn1​)1​1(ωnn−1​)2(ωnn−2​)2⋮(ωn1​)2​⋯⋯⋯⋱⋯​1(ωnn−1​)n−1(ωnn−2​)n−1⋮(ωn1​)n−1​⎦⎥⎥⎥⎥⎥⎥⎤​ 所以有： 1n[111⋯11(ωnn−1)1(ωnn−1)2⋯(ωnn−1)n−11(ωnn−2)1(ωnn−2)2⋯(ωnn−2)n−1⋮⋮⋮⋱⋮1(ωn1)1(ωn1)2⋯(ωn1)n−1][y0y1y2⋮yn−1]=[a0a1a2⋮an−1]\\dfrac{1}{n}\\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ 1 &amp; (\\omega_n ^ {n - 1}) ^ 1 &amp; (\\omega_n ^ {n - 1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 1}) ^ {n - 1} \\\\ 1 &amp; (\\omega_n ^ {n - 2}) ^ 1 &amp; (\\omega_n ^ {n - 2}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {n - 2}) ^ {n - 1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; (\\omega_n ^ {1}) ^ 1 &amp; (\\omega_n ^ {1}) ^ 2 &amp; \\cdots &amp; (\\omega_n ^ {1}) ^ {n - 1} \\end{bmatrix} \\begin{bmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_{n - 1} \\end{bmatrix} = \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n - 1} \\end{bmatrix} n1​⎣⎢⎢⎢⎢⎢⎢⎡​111⋮1​1(ωnn−1​)1(ωnn−2​)1⋮(ωn1​)1​1(ωnn−1​)2(ωnn−2​)2⋮(ωn1​)2​⋯⋯⋯⋱⋯​1(ωnn−1​)n−1(ωnn−2​)n−1⋮(ωn1​)n−1​⎦⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎡​y0​y1​y2​⋮yn−1​​⎦⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎡​a0​a1​a2​⋮an−1​​⎦⎥⎥⎥⎥⎥⎥⎤​ 所以本质上 DFT 和 IDFT 可以用同样的方法来完成，只是代入的 xxx 值不同而已。 快速傅里叶变换 (FFT) 然而 DFT 的复杂度还是 O(n2)\\mathcal{O}(n ^ 2)O(n2)，能不能更快？ 考虑使用分治。 假设我们要将多项式 A(x)=a0+a1x+a2x2+⋯+an−1xn−1A(x) = a_0 + a_1x + a_2x ^ 2 + \\cdots + a_{n - 1}x ^ {n - 1}A(x)=a0​+a1​x+a2​x2+⋯+an−1​xn−1 转为点值表示法，我们按照下标奇偶性将 A(x)A(x)A(x) 中的项分为两部分，即： A(x)=a0+a2x2+a4x4+⋯+an−2xn−2+a1x+a3x3+a5x5+⋯+an−1xn−1\\begin{aligned} A(x) &amp;= a_0 + a_2x ^ 2 + a_4x ^ 4 + \\cdots + a_{n - 2}x^{n - 2} \\\\ &amp;+ a_1x + a_3x ^ 3 + a_5x ^ 5 + \\cdots + a_{n - 1}x^{n - 1} \\\\ \\end{aligned} A(x)​=a0​+a2​x2+a4​x4+⋯+an−2​xn−2+a1​x+a3​x3+a5​x5+⋯+an−1​xn−1​ 为了方便，我们假设 nnn 为 222 的幂次，这样子除以 222 时不会出现除不尽的情况。 我们设： Aeven(x)=a0+a2x+a4x2+⋯+an−2xn/2−1Aodd(x)=a1+a3x+a5x2+⋯+an−1xn/2−1\\begin{aligned} A_{\\text{even}}(x) = a_0 + a_2x + a_4x ^ 2 + \\cdots + a_{n - 2}x^{n / 2 - 1} \\\\ A_{\\text{odd}}(x) = a_1 + a_3x + a_5x ^ 2 + \\cdots + a_{n - 1}x^{n / 2 - 1} \\end{aligned} Aeven​(x)=a0​+a2​x+a4​x2+⋯+an−2​xn/2−1Aodd​(x)=a1​+a3​x+a5​x2+⋯+an−1​xn/2−1​ 所以有： A(x)=Aeven(x2)+xAodd(x2)A(x) = A_{\\text{even}}(x ^ 2) + xA_{\\text{odd}}(x ^ 2) A(x)=Aeven​(x2)+xAodd​(x2) 划分好之后，我们尝试代入 x=ωnk (k&lt;n2)x = \\omega_n^k\\ (k \\lt \\dfrac{n}{2})x=ωnk​ (k&lt;2n​)： A(x)=Aeven(ωn2k)+ωnkAodd(ωn2k)=Aeven(ωn2k)+ωnkAodd(ωn2k)\\begin{aligned} A(x) &amp;= A_{\\text{even}}(\\omega_n^{2k}) + \\omega_n^kA_{\\text{odd}}(\\omega_n^{2k}) \\\\ &amp;= A_{\\text{even}}(\\omega_{\\frac{n}{2}}^{k}) + \\omega_n^kA_{\\text{odd}}(\\omega_{\\frac{n}{2}}^{k})\\\\ \\end{aligned} A(x)​=Aeven​(ωn2k​)+ωnk​Aodd​(ωn2k​)=Aeven​(ω2n​k​)+ωnk​Aodd​(ω2n​k​)​ 继续代入 x=ωnk+n2 (k&lt;n2)x = \\omega_n^{k + \\frac{n}{2}}\\ (k \\lt \\dfrac{n}{2})x=ωnk+2n​​ (k&lt;2n​)： A(x)=Aeven(ωn2k+n)+ωnk+n2Aodd(ωn2k+n)=Aeven(ωn2k)−ωnkAodd(ωn2k)=Aeven(ωn2k)−ωnkAodd(ωn2k)\\begin{aligned} A(x) &amp;= A_{\\text{even}}(\\omega_n^{2k + n}) + \\omega_n^{k + \\frac{n}{2}}A_{\\text{odd}}(\\omega_n^{2k + n}) \\\\ &amp;= A_{\\text{even}}(\\omega_n^{2k}) - \\omega_n^kA_{\\text{odd}}(\\omega_n^{2k}) \\\\ &amp;= A_{\\text{even}}(\\omega_{\\frac{n}{2}}^{k}) - \\omega_n^kA_{\\text{odd}}(\\omega_{\\frac{n}{2}}^{k})\\\\ \\end{aligned} A(x)​=Aeven​(ωn2k+n​)+ωnk+2n​​Aodd​(ωn2k+n​)=Aeven​(ωn2k​)−ωnk​Aodd​(ωn2k​)=Aeven​(ω2n​k​)−ωnk​Aodd​(ω2n​k​)​ 由于单位根的奇妙性质，两式仅有一个正负号不同，于是对于每个 k∈[1,n2−1]k \\in [1, \\dfrac{n}{2} - 1]k∈[1,2n​−1]，我们只需求 Aeven(ωn2k)A_{\\text{even}}(\\omega_{\\frac{n}{2}}^{k})Aeven​(ω2n​k​) 和 Aodd(ωn2k)A_{\\text{odd}}(\\omega_{\\frac{n}{2}}^{k})Aodd​(ω2n​k​) 的值即可算出 A(ωnk)A(\\omega_n^k)A(ωnk​) 和 A(ωnk+n2)A(\\omega_n^{k + \\frac{n}{2}})A(ωnk+2n​​)。 而 AevenA_{\\text{even}}Aeven​ 和 AoddA_{\\text{odd}}Aodd​ 是两个规模减半的子问题，可以递归计算。 时间复杂度 T(n)=2T(n2)+O(n)=O(nlog⁡n)T(n) = 2T(\\frac{n}{2}) + \\mathcal{O}(n) = \\mathcal{O}(n \\log n)T(n)=2T(2n​)+O(n)=O(nlogn)。 逆变换也是类似，注意到 ωnk\\omega_n^{k}ωnk​ 与 ωnn−k\\omega_n^{n - k}ωnn−k​ 互为共轭，所以只需要在单位根的虚部处加一个负号即可。 在实现时，可以将 FFT 和 IFFT 放在同个函数内实现，当 inv = 1 时为 FFT，inv = -1 时为 IFFT，减小码量。 Complex 类自己手写会快一点。 1234567891011121314151617181920212223242526272829303132struct Complex { double a, b; // a + b * i Complex() {} Complex(double _a, double _b) { a = _a; b = _b; } Complex operator + (Complex const &amp;rhs) const { return Complex(a + rhs.a, b + rhs.b); } Complex operator - (Complex const &amp;rhs) const { return Complex(a - rhs.a, b - rhs.b); } Complex operator * (Complex const &amp;rhs) const { return Complex(a * rhs.a - b * rhs.b, a * rhs.b + b * rhs.a); }};void FFT(vector&lt;Complex&gt; &amp;A, int n, int inv) { if(n == 1) return; vector&lt;Complex&gt; e(n / 2), o(n / 2); for(int i = 0; i &lt; n; i += 2) { e[i / 2] = A[i]; o[i / 2] = A[i + 1]; } FFT(e, n / 2, inv); FFT(o, n / 2, inv); Complex wn(cos(2 * PI / n), inv * sin(2 * PI / n)), wk(1, 0); for(int i = 0; i &lt; n / 2; i++, wk = wk * wn) { A[i] = e[i] + wk * o[i]; A[i + len / 2] = e[i] - wk * o[i]; }} 三次变两次优化 假设我们要求 A(x)∗B(x)A(x) * B(x)A(x)∗B(x)，我们设复多项式 P(x)=A(x)+B(x)iP(x) = A(x) + B(x)iP(x)=A(x)+B(x)i，也就是 PPP 的实部为 AAA，虚部为 BBB。 则有 P(x)2=A(x)2−B(x)2+2A(x)∗B(x)iP(x)^2 = A(x)^2 - B(x)^2 + 2A(x)*B(x)iP(x)2=A(x)2−B(x)2+2A(x)∗B(x)i，所以我们把 B(x)B(x)B(x) 的系数放到虚部上，然后求出 P(x)2P(x)^2P(x)2，将其虚部除以 222 即可。 这样一来我们只需用对 PPP 做一次 FFT 和一次 IFFT，常数是原来的 23\\dfrac{2}{3}32​。 完整代码（省略 FastIO）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define i64 long long #define all(x) x.begin(), x.end()#define seg(a, l, r) a + l, a + r + 1#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)using namespace std;using namespace FastIO;const int N = 1e6 + 5;const double PI = acos(-1.0), EPS = 1e-8;struct Complex { double a, b; // a + b * i Complex() {} Complex(double _a, double _b) { a = _a; b = _b; } Complex operator + (Complex const &amp;rhs) const { return Complex(a + rhs.a, b + rhs.b); } Complex operator - (Complex const &amp;rhs) const { return Complex(a - rhs.a, b - rhs.b); } Complex operator * (Complex const &amp;rhs) const { return Complex(a * rhs.a - b * rhs.b, a * rhs.b + b * rhs.a); }};int n, m;vector&lt;Complex&gt; a;void FFT(vector&lt;Complex&gt; &amp;arr, int len, int inv) { if(len == 1) return; vector&lt;Complex&gt; e(len / 2), o(len / 2); for(int i = 0; i &lt; len; i += 2) { e[i / 2] = arr[i]; o[i / 2] = arr[i + 1]; } FFT(e, len / 2, inv); FFT(o, len / 2, inv); Complex wn(cos(2 * PI / len), inv * sin(2 * PI / len)), wk(1, 0); for(int i = 0; i &lt; len / 2; i++, wk = wk * wn) { Complex val = wk * o[i]; arr[i] = e[i] + val; arr[i + len / 2] = e[i] - val; }}int main() { read(n); read(m); int len = 1; while(len &lt; n + m + 1) len *= 2; a.resize(len); rep(i, 0, n) { int x; read(x); a[i].a = x; } rep(i, 0, m) { int x; read(x); a[i].b = x; } FFT(a, len, 1); rep(i, 0, len - 1) a[i] = a[i] * a[i]; FFT(a, len, -1); rep(i, 0, n + m) writesp((int)round(a[i].b / 2 / len + EPS)); return flush(), 0;}","link":"/2023/10/15/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"OI Note","slug":"OI-Note","link":"/tags/OI-Note/"}],"categories":[],"pages":[]}